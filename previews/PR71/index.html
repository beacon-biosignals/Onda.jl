<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Documentation · Onda</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Onda</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>API Documentation</a><ul class="internal"><li><a class="tocitem" href="#Support-For-Generic-Path-Like-Types-1"><span>Support For Generic Path-Like Types</span></a></li><li><a class="tocitem" href="#*.onda.annotations.arrow-1"><span><code>*.onda.annotations.arrow</code></span></a></li><li><a class="tocitem" href="#*.onda.signals.arrow-1"><span><code>*.onda.signals.arrow</code></span></a></li><li><a class="tocitem" href="#Samples-1"><span><code>Samples</code></span></a></li><li><a class="tocitem" href="#LPCM-(De)serialization-API-1"><span>LPCM (De)serialization API</span></a></li><li><a class="tocitem" href="#Utilities-1"><span>Utilities</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/beacon-biosignals/Onda.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Documentation-1"><a class="docs-heading-anchor" href="#API-Documentation-1">API Documentation</a><a class="docs-heading-anchor-permalink" href="#API-Documentation-1" title="Permalink"></a></h1><p>Below is the API documentation for Onda.jl.</p><p>For general information regarding the Onda Format itself, please see <a href="https://github.com/beacon-biosignals/OndaFormat">beacon-biosignals/OndaFormat</a>.</p><p>For a nice introduction to the package, see the <a href="https://github.com/beacon-biosignals/Onda.jl/blob/master/examples/tour.jl">Onda Tour</a>.</p><h2 id="Support-For-Generic-Path-Like-Types-1"><a class="docs-heading-anchor" href="#Support-For-Generic-Path-Like-Types-1">Support For Generic Path-Like Types</a><a class="docs-heading-anchor-permalink" href="#Support-For-Generic-Path-Like-Types-1" title="Permalink"></a></h2><p>Onda.jl attempts to be as agnostic as possible with respect to the storage system that sample data, Arrow files, etc. are read from/written to. As such, any path-like argument accepted by an Onda.jl API function should generically &quot;work&quot; as long as the argument&#39;s type supports:</p><ul><li><code>Base.read(path)::Vector{UInt8}</code> (return the bytes stored at <code>path</code>)</li><li><code>Base.write(path, bytes::Vector{UInt8})</code> (write <code>bytes</code> to the location specified by <code>path</code>)</li></ul><p>For backends which support direct byte range access (e.g. S3), <code>Onda.read_byte_range</code> may be overloaded for the backend&#39;s corresponding path type to enable further optimizations:</p><article class="docstring"><header><a class="docstring-binding" id="Onda.read_byte_range" href="#Onda.read_byte_range"><code>Onda.read_byte_range</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_byte_range(path, byte_offset, byte_count)</code></pre><p>Return the equivalent <code>read(path)[(byte_offset + 1):(byte_offset + byte_count)]</code>, but try to avoid reading unreturned intermediate bytes. Note that the effectiveness of this method depends on the type of <code>path</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/utilities.jl#L82-L88">source</a></section></article><h2 id="*.onda.annotations.arrow-1"><a class="docs-heading-anchor" href="#*.onda.annotations.arrow-1"><code>*.onda.annotations.arrow</code></a><a class="docs-heading-anchor-permalink" href="#*.onda.annotations.arrow-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Onda.Annotation" href="#Onda.Annotation"><code>Onda.Annotation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Annotation(annotations_table_row)
Annotation(recording, id, span; custom...)
Annotation(; recording, id, span, custom...)</code></pre><p>Return an <code>Annotation</code> instance that represents a row of an <code>*.onda.annotations.arrow</code> table.</p><p>The names, types, and order of the columns of an <code>Annotation</code> instance are guaranteed to result in a <code>*.onda.annotations.arrow</code>-compliant row when written out via <code>write_annotations</code>.</p><p>This type primarily exists to aid in the validated construction of such rows/tables, and is not intended to be used as a type constraint in function or struct definitions. Instead, you should generally duck-type any &quot;annotation-like&quot; arguments/fields so that other generic row types will compose with your code.</p><p>This type supports Tables.jl&#39;s <code>AbstractRow</code> interface (but does not subtype <code>AbstractRow</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/annotations.jl#L22-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.read_annotations" href="#Onda.read_annotations"><code>Onda.read_annotations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_annotations(io_or_path; validate_schema::Bool=true)</code></pre><p>Return the <code>*.onda.annotations.arrow</code>-compliant table read from <code>io_or_path</code>.</p><p>If <code>validate_schema</code> is <code>true</code>, the table&#39;s schema will be validated to ensure it is a <code>*.onda.annotations.arrow</code>-compliant table. An <code>ArgumentError</code> will be thrown if any schema violation is detected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/annotations.jl#L68-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.write_annotations" href="#Onda.write_annotations"><code>Onda.write_annotations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">write_annotations(io_or_path, table; kwargs...)</code></pre><p>Write <code>table</code> to <code>io_or_path</code>, first validating that <code>table</code> is a <code>*.onda.annotations.arrow</code>-compliant table. An <code>ArgumentError</code> will be thrown if any schema violation is detected.</p><p><code>kwargs</code> is forwarded to an internal invocation of <code>Arrow.write(...; file=true, kwargs...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/annotations.jl#L91-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.merge_overlapping_annotations" href="#Onda.merge_overlapping_annotations"><code>Onda.merge_overlapping_annotations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">merge_overlapping_annotations(annotations)</code></pre><p>Given the <code>*.onda.annotations.arrow</code>-compliant table <code>annotations</code>, return a table corresponding to <code>annotations</code> except that overlapping entries have been merged.</p><p>Specifically, two annotations <code>a</code> and <code>b</code> are determined to be &quot;overlapping&quot; if <code>a.recording == b.recording &amp;&amp; TimeSpans.overlaps(a.span, b.span)</code>. Merged annotations&#39; <code>span</code> fields are generated via calling <code>TimeSpans.shortest_timespan_containing</code> on the overlapping set of source annotations.</p><p>The returned annotations table only has a single custom column named <code>from</code> whose entries are <code>Vector{UUID}</code>s populated with the <code>id</code>s of the generated annotations&#39; source(s). Note that every annotation in the returned table has a freshly generated <code>id</code> field and a non-empty <code>from</code> field, even if the <code>from</code> only has a single element (i.e. corresponds to a single non-overlapping annotation).</p><p>Note that this function internally works with <code>Tables.columns(annotations)</code> rather than <code>annotations</code> directly, so it may be slower and/or require more memory if <code>!Tables.columnaccess(annotations)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/annotations.jl#L116-L138">source</a></section></article><h2 id="*.onda.signals.arrow-1"><a class="docs-heading-anchor" href="#*.onda.signals.arrow-1"><code>*.onda.signals.arrow</code></a><a class="docs-heading-anchor-permalink" href="#*.onda.signals.arrow-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Onda.Signal" href="#Onda.Signal"><code>Onda.Signal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Signal(signals_table_row)
Signal(recording, file_path, file_format, span, kind, channels, sample_unit,
       sample_resolution_in_unit, sample_offset_in_unit, sample_type, sample_rate;
       custom...)
Signal(; recording, file_path, file_format, span, kind, channels, sample_unit,
       sample_resolution_in_unit, sample_offset_in_unit, sample_type, sample_rate,
       custom...)
Signal(info::SamplesInfo; recording, file_path, file_format, span, custom...)</code></pre><p>Return a <code>Signal</code> instance that represents a row of an <code>*.onda.signals.arrow</code> table</p><p>The names, types, and order of the columns of a <code>Signal</code> instance are guaranteed to result in a <code>*.onda.signals.arrow</code>-compliant row when written out via <code>write_signals</code>. The exception is the <code>file_path</code> column, whose type is unchecked in order to allow callers to utilize custom path types.</p><p>This type primarily exists to aid in the validated construction of such rows/tables, and is not intended to be used as a type constraint in function or struct definitions. Instead, you should generally duck-type any &quot;signal-like&quot; arguments/fields so that other generic row types will compose with your code.</p><p>This type supports Tables.jl&#39;s <code>AbstractRow</code> interface (but does not subtype <code>AbstractRow</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/signals.jl#L64-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.SamplesInfo" href="#Onda.SamplesInfo"><code>Onda.SamplesInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SamplesInfo(; kind, channels, sample_unit,
            sample_resolution_in_unit, sample_offset_in_unit,
            sample_type, sample_rate,
            validate::Bool=Onda.validate_on_construction())
SamplesInfo(kind, channels, sample_unit,
            sample_resolution_in_unit, sample_offset_in_unit,
            sample_type, sample_rate;
            validate::Bool=Onda.validate_on_construction())
SamplesInfo(signals_table_row; validate::Bool=Onda.validate_on_construction())</code></pre><p>Return a <code>SamplesInfo</code> instance whose fields are a subset of a <code>*.onda.signals.arrow</code> row:</p><ul><li><code>kind</code></li><li><code>channels</code></li><li><code>sample_unit</code></li><li><code>sample_resolution_in_unit</code></li><li><code>sample_offset_in_unit</code></li><li><code>sample_type</code></li><li><code>sample_rate</code></li></ul><p>The <code>SamplesInfo</code> struct bundles together the fields of a <code>*.onda.signals.arrow</code> row that are intrinsic to a signal&#39;s sample data, leaving out extrinsic file or recording information. This is useful when the latter information is irrelevant or does not yet exist (e.g. if sample data is being constructed/manipulated in-memory without yet having been serialized).</p><p>Bundling these fields together under a common type facilitates dispatch for various Onda API functions. Additionally:</p><ul><li><p>If <code>validate</code> is <code>true</code>, then <code>Onda.validate</code> is called on new instances upon construction.</p></li><li><p>The provided <code>sample_type</code> may be either an Onda-compliant string or a <code>DataType</code>. If it is a string, it will be converted to its corresponding <code>DataType</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/signals.jl#L183-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.validate" href="#Onda.validate"><code>Onda.validate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">validate(info::SamplesInfo)</code></pre><p>Returns <code>nothing</code>, checking that the given <code>info.kind</code>, <code>info.channels</code> and <code>info.sample_unit</code> are valid w.r.t. the Onda specification. If a violation is found, an <code>ArgumentError</code> is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/signals.jl#L259-L264">source</a></section><section><div><pre><code class="language-none">validate(samples::Samples)</code></pre><p>Returns <code>nothing</code>, checking that the given <code>samples</code> are valid w.r.t. the underlying <code>samples.info</code> and the Onda specification&#39;s canonical LPCM representation. If a violation is found, an <code>ArgumentError</code> is thrown.</p><p>Properties that are validated by this function include:</p><ul><li>encoded element type matches <code>samples.info.sample_type</code></li><li>the number of rows of <code>samples.data</code> matches the number of channels in <code>samples.info</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/samples.jl#L50-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.read_signals" href="#Onda.read_signals"><code>Onda.read_signals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_signals(io_or_path; validate_schema::Bool=false)</code></pre><p>Return the <code>*.onda.signals.arrow</code>-compliant table read from <code>io_or_path</code>.</p><p>If <code>validate_schema</code> is <code>true</code>, the table&#39;s schema will be validated to ensure it is a <code>*.onda.signals.arrow</code>-compliant table. An <code>ArgumentError</code> will be thrown if any schema violation is detected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/signals.jl#L135-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.write_signals" href="#Onda.write_signals"><code>Onda.write_signals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">write_signals(io_or_path, table; kwargs...)</code></pre><p>Write <code>table</code> to <code>io_or_path</code>, first validating that <code>table</code> is a compliant <code>*.onda.signals.arrow</code> table. An <code>ArgumentError</code> will be thrown if any schema violation is detected.</p><p><code>kwargs</code> is forwarded to an internal invocation of <code>Arrow.write(...; file=true, kwargs...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/signals.jl#L158-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel-Tuple{Any, Any}" href="#Onda.channel-Tuple{Any, Any}"><code>Onda.channel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">channel(x, name)</code></pre><p>Return <code>i</code> where <code>x.channels[i] == name</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/signals.jl#L286-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel-Tuple{Any, Integer}" href="#Onda.channel-Tuple{Any, Integer}"><code>Onda.channel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">channel(x, i::Integer)</code></pre><p>Return <code>x.channels[i]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/signals.jl#L293-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel_count-Tuple{Any}" href="#Onda.channel_count-Tuple{Any}"><code>Onda.channel_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">channel_count(x)</code></pre><p>Return <code>length(x.channels)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/signals.jl#L300-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.sample_count-Tuple{Any, Dates.Period}" href="#Onda.sample_count-Tuple{Any, Dates.Period}"><code>Onda.sample_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sample_count(x, duration::Period)</code></pre><p>Return the number of multichannel samples that fit within <code>duration</code> given <code>x.sample_rate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/signals.jl#L307-L311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.sizeof_samples-Tuple{Any, Dates.Period}" href="#Onda.sizeof_samples-Tuple{Any, Dates.Period}"><code>Onda.sizeof_samples</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sizeof_samples(x, duration::Period)</code></pre><p>Returns the expected size (in bytes) of an encoded <code>Samples</code> object corresponding to <code>x</code> and <code>duration</code>:</p><pre><code class="language-none">sample_count(x, duration) * channel_count(x) * sizeof(x.sample_type)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/signals.jl#L314-L321">source</a></section></article><h2 id="Samples-1"><a class="docs-heading-anchor" href="#Samples-1"><code>Samples</code></a><a class="docs-heading-anchor-permalink" href="#Samples-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Onda.Samples" href="#Onda.Samples"><code>Onda.Samples</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Samples(data::AbstractMatrix, info::SamplesInfo, encoded::Bool;
        validate::Bool=Onda.validate_on_construction())</code></pre><p>Return a <code>Samples</code> instance with the following fields:</p><ul><li><p><code>data::AbstractMatrix</code>: A matrix of sample data. The <code>i</code> th row of the matrix corresponds to the <code>i</code>th channel in <code>info.channels</code>, while the <code>j</code>th column corresponds to the <code>j</code>th multichannel sample.</p></li><li><p><code>info::SamplesInfo</code>: The <code>SamplesInfo</code> object that describes the <code>Samples</code> instance.</p></li><li><p><code>encoded::Bool</code>: If <code>true</code>, the values in <code>data</code> are LPCM-encoded as prescribed by the <code>Samples</code> instance&#39;s <code>info</code>. If <code>false</code>, the values in <code>data</code> have been decoded into the <code>info</code>&#39;s canonical units.</p></li></ul><p>If <code>validate</code> is <code>true</code>, <a href="#Onda.validate"><code>Onda.validate</code></a> is called on the constructed <code>Samples</code> instance before it is returned.</p><p>Note that <code>getindex</code> and <code>view</code> are defined on <code>Samples</code> to accept normal integer indices, but also accept channel names or a regex to match channel names for row indices, and <code>TimeSpan</code> values for column indices; see <code>Onda/examples/tour.jl</code> for a comprehensive set of indexing examples.</p><p>See also: <a href="#Onda.load"><code>load</code></a>, <a href="#Onda.store"><code>store</code></a>, <a href="#Onda.encode"><code>encode</code></a>, <a href="#Onda.encode!"><code>encode!</code></a>, <a href="#Onda.decode"><code>decode</code></a>, <a href="#Onda.decode!"><code>decode!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/samples.jl#L5-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{Samples, Samples}" href="#Base.:==-Tuple{Samples, Samples}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">==(a::Samples, b::Samples)</code></pre><p>Returns <code>a.encoded == b.encoded &amp;&amp; a.info == b.info &amp;&amp; a.data == b.data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/samples.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel" href="#Onda.channel"><code>Onda.channel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">channel(x, name)</code></pre><p>Return <code>i</code> where <code>x.channels[i] == name</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/signals.jl#L286-L290">source</a></section><section><div><pre><code class="language-julia">channel(x, i::Integer)</code></pre><p>Return <code>x.channels[i]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/signals.jl#L293-L297">source</a></section><section><div><pre><code class="language-julia">channel(samples::Samples, name)</code></pre><p>Return <code>channel(samples.info, name)</code>.</p><p>This function is useful for indexing rows of <code>samples.data</code> by channel names.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/samples.jl#L80-L86">source</a></section><section><div><pre><code class="language-julia">channel(samples::Samples, i::Integer)</code></pre><p>Return <code>channel(samples.info, i)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/samples.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel_count" href="#Onda.channel_count"><code>Onda.channel_count</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">channel_count(x)</code></pre><p>Return <code>length(x.channels)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/signals.jl#L300-L304">source</a></section><section><div><pre><code class="language-julia">channel_count(samples::Samples)</code></pre><p>Return <code>channel_count(samples.info)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/samples.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.sample_count" href="#Onda.sample_count"><code>Onda.sample_count</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sample_count(x, duration::Period)</code></pre><p>Return the number of multichannel samples that fit within <code>duration</code> given <code>x.sample_rate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/signals.jl#L307-L311">source</a></section><section><div><pre><code class="language-julia">sample_count(samples::Samples)</code></pre><p>Return the number of multichannel samples in <code>samples</code> (i.e. <code>size(samples.data, 2)</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/samples.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.encode" href="#Onda.encode"><code>Onda.encode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">encode(sample_type::DataType, sample_resolution_in_unit, sample_offset_in_unit,
       sample_data, dither_storage=nothing)</code></pre><p>Return a copy of <code>sample_data</code> quantized according to <code>sample_type</code>, <code>sample_resolution_in_unit</code>, and <code>sample_offset_in_unit</code>. <code>sample_type</code> must be a concrete subtype of <code>Onda.VALID_SAMPLE_TYPE_UNION</code>. Quantization of an individual sample <code>s</code> is performed via:</p><pre><code class="language-none">round(S, (s - sample_offset_in_unit) / sample_resolution_in_unit)</code></pre><p>with additional special casing to clip values exceeding the encoding&#39;s dynamic range.</p><p>If <code>dither_storage isa Nothing</code>, no dithering is applied before quantization.</p><p>If <code>dither_storage isa Missing</code>, dither storage is allocated automatically and triangular dithering is applied to the info prior to quantization.</p><p>Otherwise, <code>dither_storage</code> must be a container of similar shape and type to <code>sample_data</code>. This container is then used to store the random noise needed for the triangular dithering process, which is applied to the info prior to quantization.</p><p>If:</p><pre><code class="language-none">sample_type === eltype(sample_data) &amp;&amp;
sample_resolution_in_unit == 1 &amp;&amp;
sample_offset_in_unit == 0</code></pre><p>then this function will simply return <code>sample_data</code> directly without copying/dithering.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/samples.jl#L178-L206">source</a></section><section><div><pre><code class="language-none">encode(samples::Samples, dither_storage=nothing)</code></pre><p>If <code>samples.encoded</code> is <code>false</code>, return a <code>Samples</code> instance that wraps:</p><pre><code class="language-none">encode(samples.info.sample_type,
       samples.info.sample_resolution_in_unit,
       samples.info.sample_offset_in_unit,
       samples.data, dither_storage)</code></pre><p>If <code>samples.encoded</code> is <code>true</code>, this function is the identity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/samples.jl#L270-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.encode!" href="#Onda.encode!"><code>Onda.encode!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">encode!(result_storage, sample_type::DataType, sample_resolution_in_unit,
        sample_offset_in_unit, sample_data, dither_storage=nothing)
encode!(result_storage, sample_resolution_in_unit, sample_offset_in_unit,
        sample_data, dither_storage=nothing)</code></pre><p>Similar to <code>encode(sample_type, sample_resolution_in_unit, sample_offset_in_unit, sample_data, dither_storage)</code>, but write encoded values to <code>result_storage</code> rather than allocating new storage.</p><p><code>sample_type</code> defaults to <code>eltype(result_storage)</code> if it is not provided.</p><p>If:</p><pre><code class="language-none">sample_type === eltype(sample_data) &amp;&amp;
sample_resolution_in_unit == 1 &amp;&amp;
sample_offset_in_unit == 0</code></pre><p>then this function will simply copy <code>sample_data</code> directly into <code>result_storage</code> without dithering.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/samples.jl#L219-L237">source</a></section><section><div><pre><code class="language-none">encode!(result_storage, samples::Samples, dither_storage=nothing)</code></pre><p>If <code>samples.encoded</code> is <code>false</code>, return a <code>Samples</code> instance that wraps:</p><pre><code class="language-none">encode!(result_storage,
        samples.info.sample_type,
        samples.info.sample_resolution_in_unit,
        samples.info.sample_offset_in_unit,
        samples.data, dither_storage)`.</code></pre><p>If <code>samples.encoded</code> is <code>true</code>, return a <code>Samples</code> instance that wraps <code>copyto!(result_storage, samples.data)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/samples.jl#L291-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.decode" href="#Onda.decode"><code>Onda.decode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">decode(sample_resolution_in_unit, sample_offset_in_unit, sample_data)</code></pre><p>Return <code>sample_resolution_in_unit .* sample_data .+ sample_offset_in_unit</code>.</p><p>If:</p><pre><code class="language-none">sample_data isa AbstractArray &amp;&amp;
sample_resolution_in_unit == 1 &amp;&amp;
sample_offset_in_unit == 0</code></pre><p>then this function is the identity and will return <code>sample_data</code> directly without copying.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/samples.jl#L321-L333">source</a></section><section><div><pre><code class="language-none">decode(samples::Samples)</code></pre><p>If <code>samples.encoded</code> is <code>true</code>, return a <code>Samples</code> instance that wraps</p><pre><code class="language-none">decode(samples.info.sample_resolution_in_unit, samples.info.sample_offset_in_unit, samples.data)</code></pre><p>If <code>samples.encoded</code> is <code>false</code>, this function is the identity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/samples.jl#L352-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.decode!" href="#Onda.decode!"><code>Onda.decode!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">decode!(result_storage, sample_resolution_in_unit, sample_offset_in_unit, sample_data)</code></pre><p>Similar to <code>decode(sample_resolution_in_unit, sample_offset_in_unit, sample_data)</code>, but write decoded values to <code>result_storage</code> rather than allocating new storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/samples.jl#L341-L346">source</a></section><section><div><pre><code class="language-none">decode!(result_storage, samples::Samples)</code></pre><p>If <code>samples.encoded</code> is <code>true</code>, return a <code>Samples</code> instance that wraps</p><pre><code class="language-none">decode!(result_storage, samples.info.sample_resolution_in_unit, samples.info.sample_offset_in_unit, samples.data)</code></pre><p>If <code>samples.encoded</code> is <code>false</code>, return a <code>Samples</code> instance that wraps <code>copyto!(result_storage, samples.data)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/samples.jl#L369-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.load" href="#Onda.load"><code>Onda.load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">load(signal[, span]; encoded::Bool=false)
load(file_path, file_format::Union{AbstractString,AbstractLPCMFormat}, info::SamplesInfo[, span]; encoded::Bool=false)</code></pre><p>Return the <code>Samples</code> object described by <code>signal</code>/<code>file_path</code>/<code>file_format</code>/<code>info</code>.</p><p>If <code>span</code> is present, return <code>load(...)[:, span]</code>, but attempt to avoid reading unreturned intermediate sample data. Note that the effectiveness of this optimized method versus the naive approach depends on the types of <code>file_path</code> (i.e. if there is a fast method defined for <code>Onda.read_byte_range(::typeof(file_path), ...)</code>) and <code>file_format</code> (i.e. does the corresponding format support random or chunked access).</p><p>If <code>encoded</code> is <code>true</code>, do not decode the <code>Samples</code> object before returning it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/samples.jl#L392-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.mmap" href="#Onda.mmap"><code>Onda.mmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Onda.mmap(signal)</code></pre><p>Return <code>Onda.mmap(signal.file_path, SamplesInfo(signal))</code>, throwing an <code>ArgumentError</code> if <code>signal.file_format != &quot;lpcm&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/samples.jl#L427-L431">source</a></section><section><div><pre><code class="language-none">Onda.mmap(mmappable, info::SamplesInfo)</code></pre><p>Return <code>Samples(data, info, true)</code> where <code>data</code> is created via <code>Mmap.mmap(mmappable, ...)</code>.</p><p><code>mmappable</code> is assumed to reference memory that is formatted according to the Onda Format&#39;s canonical interleaved LPCM representation in accordance with <code>info.sample_type</code> and <code>channel_count(info)</code>. No explicit checks are performed to ensure that this is true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/samples.jl#L437-L445">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.store" href="#Onda.store"><code>Onda.store</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">store(file_path, file_format::Union{AbstractString,AbstractLPCMFormat}, samples::Samples)</code></pre><p>Serialize the given <code>samples</code> to <code>file_format</code> and write the output to <code>file_path</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/samples.jl#L451-L455">source</a></section><section><div><pre><code class="language-none">store(file_path, file_format::Union{AbstractString,AbstractLPCMFormat}, samples::Samples,
      recording::UUID, start::Period; custom...)</code></pre><p>Serialize the given <code>samples</code> to <code>file_format</code> and write the output to <code>file_path</code>, returning a <code>Signal</code> instance constructed from the provided arguments (any provided <code>custom</code> keyword arguments are forwarded to an invocation of the <code>Signal</code> constructor).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/samples.jl#L461-L468">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel-Tuple{Samples, Any}" href="#Onda.channel-Tuple{Samples, Any}"><code>Onda.channel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">channel(samples::Samples, name)</code></pre><p>Return <code>channel(samples.info, name)</code>.</p><p>This function is useful for indexing rows of <code>samples.data</code> by channel names.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/samples.jl#L80-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel-Tuple{Samples, Integer}" href="#Onda.channel-Tuple{Samples, Integer}"><code>Onda.channel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">channel(samples::Samples, i::Integer)</code></pre><p>Return <code>channel(samples.info, i)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/samples.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel_count-Tuple{Samples}" href="#Onda.channel_count-Tuple{Samples}"><code>Onda.channel_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">channel_count(samples::Samples)</code></pre><p>Return <code>channel_count(samples.info)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/samples.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.sample_count-Tuple{Samples}" href="#Onda.sample_count-Tuple{Samples}"><code>Onda.sample_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sample_count(samples::Samples)</code></pre><p>Return the number of multichannel samples in <code>samples</code> (i.e. <code>size(samples.data, 2)</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/samples.jl#L103-L107">source</a></section></article><h2 id="LPCM-(De)serialization-API-1"><a class="docs-heading-anchor" href="#LPCM-(De)serialization-API-1">LPCM (De)serialization API</a><a class="docs-heading-anchor-permalink" href="#LPCM-(De)serialization-API-1" title="Permalink"></a></h2><p>Onda.jl&#39;s LPCM (De)serialization API facilitates low-level streaming sample data (de)serialization and provides a storage-agnostic abstraction layer that can be overloaded to support new file/byte formats for (de)serializing LPCM-encodeable sample data.</p><article class="docstring"><header><a class="docstring-binding" id="Onda.AbstractLPCMFormat" href="#Onda.AbstractLPCMFormat"><code>Onda.AbstractLPCMFormat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractLPCMFormat</code></pre><p>A type whose subtypes represents byte/stream formats that can be (de)serialized to/from Onda&#39;s standard interleaved LPCM representation.</p><p>All subtypes of the form <code>F&lt;:AbstractLPCMFormat</code> must call <a href="#Onda.register_lpcm_format!"><code>Onda.register_lpcm_format!</code></a> and define an appropriate <a href="#Onda.file_format_string"><code>file_format_string</code></a> method.</p><p>See also:</p><ul><li><a href="#Onda.format"><code>format</code></a></li><li><a href="#Onda.deserialize_lpcm"><code>deserialize_lpcm</code></a></li><li><a href="#Onda.deserialize_lpcm_callback"><code>deserialize_lpcm_callback</code></a></li><li><a href="#Onda.serialize_lpcm"><code>serialize_lpcm</code></a></li><li><a href="#Onda.LPCMFormat"><code>LPCMFormat</code></a></li><li><a href="#Onda.LPCMZstFormat"><code>LPCMZstFormat</code></a></li><li><a href="#Onda.AbstractLPCMStream"><code>AbstractLPCMStream</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/serialization.jl#L43-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.AbstractLPCMStream" href="#Onda.AbstractLPCMStream"><code>Onda.AbstractLPCMStream</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractLPCMStream</code></pre><p>A type that represents an LPCM (de)serialization stream.</p><p>See also:</p><ul><li><a href="#Onda.deserializing_lpcm_stream"><code>deserializing_lpcm_stream</code></a></li><li><a href="#Onda.serializing_lpcm_stream"><code>serializing_lpcm_stream</code></a></li><li><a href="#Onda.finalize_lpcm_stream"><code>finalize_lpcm_stream</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/serialization.jl#L64-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.LPCMFormat" href="#Onda.LPCMFormat"><code>Onda.LPCMFormat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LPCMFormat(channel_count::Int, sample_type::Type)
LPCMFormat(info::SamplesInfo)</code></pre><p>Return a <code>LPCMFormat&lt;:AbstractLPCMFormat</code> instance corresponding to Onda&#39;s default interleaved LPCM format assumed for sample data files with the &quot;lpcm&quot; extension.</p><p><code>channel_count</code> corresponds to <code>length(info.channels)</code>, while <code>sample_type</code> corresponds to <code>info.sample_type</code></p><p>Note that bytes (de)serialized to/from this format are little-endian (per the Onda specification).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/serialization.jl#L207-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.LPCMZstFormat" href="#Onda.LPCMZstFormat"><code>Onda.LPCMZstFormat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LPCMZstFormat(lpcm::LPCMFormat; level=3)
LPCMZstFormat(info::SamplesInfo; level=3)</code></pre><p>Return a <code>LPCMZstFormat&lt;:AbstractLPCMFormat</code> instance that corresponds to Onda&#39;s default interleaved LPCM format compressed by <code>zstd</code>. This format is assumed for sample data files with the &quot;lpcm.zst&quot; extension.</p><p>The <code>level</code> keyword argument sets the same compression level parameter as the corresponding flag documented by the <code>zstd</code> command line utility.</p><p>See https://facebook.github.io/zstd/ for details about <code>zstd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/serialization.jl#L304-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.format" href="#Onda.format"><code>Onda.format</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">format(file_format::AbstractString, info::SamplesInfo; kwargs...)</code></pre><p>Return <code>f(info; kwargs...)</code> where <code>f</code> constructs the <code>AbstractLPCMFormat</code> instance that corresponds to <code>file_format</code>. <code>f</code> is determined by matching <code>file_format</code> to a suitable format constuctor registered via <a href="#Onda.register_lpcm_format!"><code>register_lpcm_format!</code></a>.</p><p>See also: <a href="#Onda.deserialize_lpcm"><code>deserialize_lpcm</code></a>, <a href="#Onda.serialize_lpcm"><code>serialize_lpcm</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/serialization.jl#L25-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.deserialize_lpcm" href="#Onda.deserialize_lpcm"><code>Onda.deserialize_lpcm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">deserialize_lpcm(format::AbstractLPCMFormat, bytes,
                 samples_offset::Integer=0,
                 samples_count::Integer=typemax(Int))
deserialize_lpcm(stream::AbstractLPCMStream,
                 samples_offset::Integer=0,
                 samples_count::Integer=typemax(Int))</code></pre><p>Return a channels-by-timesteps <code>AbstractMatrix</code> of interleaved LPCM-encoded sample data by deserializing the provided <code>bytes</code> in the given <code>format</code>, or from the given <code>stream</code> constructed by <a href="#Onda.deserializing_lpcm_stream"><code>deserializing_lpcm_stream</code></a>.</p><p>Note that this operation may be performed in a zero-copy manner such that the returned sample matrix directly aliases <code>bytes</code>.</p><p>The returned segment is at most <code>sample_offset</code> samples offset from the start of <code>stream</code>/<code>bytes</code> and contains at most <code>sample_count</code> samples. This ensures that overrun behavior is generally similar to the behavior of <code>Base.skip(io, n)</code> and <code>Base.read(io, n)</code>.</p><p>This function is the inverse of the corresponding <a href="#Onda.serialize_lpcm"><code>serialize_lpcm</code></a> method, i.e.:</p><pre><code class="language-none">serialize_lpcm(format, deserialize_lpcm(format, bytes)) == bytes</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/serialization.jl#L130-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.serialize_lpcm" href="#Onda.serialize_lpcm"><code>Onda.serialize_lpcm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">serialize_lpcm(format::AbstractLPCMFormat, samples::AbstractMatrix)
serialize_lpcm(stream::AbstractLPCMStream, samples::AbstractMatrix)</code></pre><p>Return the <code>AbstractVector{UInt8}</code> of bytes that results from serializing <code>samples</code> to the given <code>format</code> (or serialize those bytes directly to <code>stream</code>) where <code>samples</code> is a channels-by-timesteps matrix of interleaved LPCM-encoded sample data.</p><p>Note that this operation may be performed in a zero-copy manner such that the returned <code>AbstractVector{UInt8}</code> directly aliases <code>samples</code>.</p><p>This function is the inverse of the corresponding <a href="#Onda.deserialize_lpcm"><code>deserialize_lpcm</code></a> method, i.e.:</p><pre><code class="language-none">deserialize_lpcm(format, serialize_lpcm(format, samples)) == samples</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/serialization.jl#L158-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.deserialize_lpcm_callback" href="#Onda.deserialize_lpcm_callback"><code>Onda.deserialize_lpcm_callback</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">deserialize_lpcm_callback(format::AbstractLPCMFormat, samples_offset, samples_count)</code></pre><p>Return <code>(callback, required_byte_offset, required_byte_count)</code> where <code>callback</code> accepts the byte block specified by <code>required_byte_offset</code> and <code>required_byte_count</code> and returns the samples specified by <code>samples_offset</code> and <code>samples_count</code>.</p><p>As a fallback, this function returns <code>(callback, missing, missing)</code>, where <code>callback</code> requires all available bytes. <code>AbstractLPCMFormat</code> subtypes that support partial/block-based deserialization (e.g. the basic <code>LPCMFormat</code>) can overload this function to only request exactly the byte range that is required for the sample range requested by the caller.</p><p>This allows callers to handle the byte block retrieval themselves while keeping Onda&#39;s LPCM Serialization API agnostic to the caller&#39;s storage layer of choice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/serialization.jl#L77-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.deserializing_lpcm_stream" href="#Onda.deserializing_lpcm_stream"><code>Onda.deserializing_lpcm_stream</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">deserializing_lpcm_stream(format::AbstractLPCMFormat, io)</code></pre><p>Return a <code>stream::AbstractLPCMStream</code> that wraps <code>io</code> to enable direct LPCM deserialization from <code>io</code> via <a href="#Onda.deserialize_lpcm"><code>deserialize_lpcm</code></a>.</p><p>Note that <code>stream</code> must be finalized after usage via <a href="#Onda.finalize_lpcm_stream"><code>finalize_lpcm_stream</code></a>. Until <code>stream</code> is finalized, <code>io</code> should be considered to be part of the internal state of <code>stream</code> and should not be directly interacted with by other processes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/serialization.jl#L97-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.serializing_lpcm_stream" href="#Onda.serializing_lpcm_stream"><code>Onda.serializing_lpcm_stream</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">serializing_lpcm_stream(format::AbstractLPCMFormat, io)</code></pre><p>Return a <code>stream::AbstractLPCMStream</code> that wraps <code>io</code> to enable direct LPCM serialization to <code>io</code> via <a href="#Onda.serialize_lpcm"><code>serialize_lpcm</code></a>.</p><p>Note that <code>stream</code> must be finalized after usage via <a href="#Onda.finalize_lpcm_stream"><code>finalize_lpcm_stream</code></a>. Until <code>stream</code> is finalized, <code>io</code> should be considered to be part of the internal state of <code>stream</code> and should not be directly interacted with by other processes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/serialization.jl#L109-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.finalize_lpcm_stream" href="#Onda.finalize_lpcm_stream"><code>Onda.finalize_lpcm_stream</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">finalize_lpcm_stream(stream::AbstractLPCMStream)::Bool</code></pre><p>Finalize <code>stream</code>, returning <code>true</code> if the underlying I/O object used to construct <code>stream</code> is still open and usable. Otherwise, return <code>false</code> to indicate that underlying I/O object was closed as result of finalization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/serialization.jl#L121-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.register_lpcm_format!" href="#Onda.register_lpcm_format!"><code>Onda.register_lpcm_format!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Onda.register_lpcm_format!(create_constructor)</code></pre><p>Register an <code>AbstractLPCMFormat</code> constructor so that it can automatically be used when <a href="#Onda.format"><code>format</code></a> is called. Authors of new <code>AbstractLPCMFormat</code> subtypes should call this function for their subtype.</p><p><code>create_constructor</code> should be a unary function that accepts a single <code>file_format::AbstractString</code> argument, and return either a matching <code>AbstractLPCMFormat</code> constructor or <code>nothing</code>. Any returned <code>AbstractLPCMFormat</code> constructor <code>f</code> should be of the form <code>f(info::SamplesInfo; kwargs...)::AbstractLPCMFormat</code>.</p><p>Note that if <code>Onda.register_lpcm_format!</code> is called in a downstream package, it must be called within the <code>__init__</code> function of the package&#39;s top-level module to ensure that the function is always invoked when the module is loaded (not just during precompilation). For details, see https://docs.julialang.org/en/v1/manual/modules/#Module-initialization-and-precompilation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/serialization.jl#L7-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.file_format_string" href="#Onda.file_format_string"><code>Onda.file_format_string</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">file_format_string(format::AbstractLPCMFormat)</code></pre><p>Return the <code>String</code> representation of <code>format</code> to be written to the <code>file_format</code> field of a <code>*.signals</code> file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/serialization.jl#L178-L182">source</a></section></article><h2 id="Utilities-1"><a class="docs-heading-anchor" href="#Utilities-1">Utilities</a><a class="docs-heading-anchor-permalink" href="#Utilities-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Onda.materialize" href="#Onda.materialize"><code>Onda.materialize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">materialize(table)</code></pre><p>Return a fully deserialized copy of <code>table</code>.</p><p>This function is useful when <code>table</code> has built-in deserialize-on-access or conversion-on-access behavior (like <code>Arrow.Table</code>) and you&#39;d like to pay such access costs upfront before repeatedly accessing the table. For example:</p><pre><code class="language-none">julia&gt; annotations = read_annotations(path_to_annotations_file);

# iterate through all elements of `annotations.span`
julia&gt; @time foreach(identity, (span for span in annotations.span));
0.000126 seconds (306 allocations: 6.688 KiB)

julia&gt; materialized = Onda.materialize(annotations);

julia&gt; @time foreach(identity, (span for span in materialized.span));
  0.000014 seconds (2 allocations: 80 bytes)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/utilities.jl#L180-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.gather" href="#Onda.gather"><code>Onda.gather</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gather(column_name, tables...; extract=((table, idxs) -&gt; view(table, idxs, :)))</code></pre><p>Gather rows from <code>tables</code> into a unified cross-table index along <code>column_name</code>. Returns a <code>Dict</code> whose keys are the unique values of <code>column_name</code> across <code>tables</code>, and whose values are tuples of the form:</p><pre><code class="language-none">(rows_matching_key_in_table_1, rows_matching_key_in_table_2, ...)</code></pre><p>The provided <code>extract</code> function is used to extract rows from each table; it takes as input a table and a <code>Vector{Int}</code> of row indices, and returns the corresponding subtable. The default definition is sufficient for <code>DataFrames</code> tables.</p><p>Note that this function may internally call <code>Tables.columns</code> on each input table, so it may be slower and/or require more memory if <code>any(!Tables.columnaccess, tables)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/utilities.jl#L158-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.validate_on_construction" href="#Onda.validate_on_construction"><code>Onda.validate_on_construction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Onda.validate_on_construction()</code></pre><p>Returns <code>true</code> by default.</p><p>If this function returns <code>true</code>, various Onda objects will be validated upon construction for compliance with the Onda specification.</p><p>Users may interactively redefine this method to <code>false</code> in order to disable this extra layer validation, which can be useful when working with malformed Onda datasets.</p><p>See also: <a href="#Onda.validate"><code>Onda.validate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/utilities.jl#L7-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.upgrade_onda_dataset_to_v0_5!" href="#Onda.upgrade_onda_dataset_to_v0_5!"><code>Onda.upgrade_onda_dataset_to_v0_5!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">upgrade_onda_dataset_to_v0_5!(dataset_path;
                              verbose=true,
                              uuid_from_annotation=(_ -&gt; uuid4()),
                              signal_file_path=((uuid, kind, ext) -&gt; joinpath(&quot;samples&quot;, string(uuid), kind * &quot;.&quot; * ext)),
                              signal_file_format=((ext, opts) -&gt; ext),
                              kwargs...)</code></pre><p>Upgrade a Onda Format v0.3/v0.4 dataset to Onda Format v0.5 by converting the dataset&#39;s <code>recordings.msgpack.zst</code> file into <code>upgraded.onda.signals.arrow</code> and upgraded.onda.annotations.arrow` files written to the root of the dataset (w/o deleting existing content).</p><p>Returns a tuple <code>(signals, annotations)</code> where <code>signals</code> is the table corresponding to <code>upgraded.onda.signals.arrow</code> and <code>annotations</code> is the table corresponding to <code>upgraded.onda.annotations.arrow</code>.</p><ul><li><p>If <code>verbose</code> is <code>true</code>, this function will print out timestamped progress logs.</p></li><li><p><code>uuid_from_annotation</code> is an function that takes in an Onda Format v0.3/v0.4</p></li></ul><p>annotation (as a <code>Dict{String}</code>) and returns the <code>id</code> field to be associated with that annotation.</p><ul><li><code>signal_file_path</code> is a function that takes in a signal&#39;s recording UUID, the</li></ul><p>signal&#39;s kind (formerly the <code>name</code> field), and the signal&#39;s <code>file_extension</code> field and returns the <code>file_path</code> field to be associated with that signal.</p><ul><li><code>signal_file_format</code> is a function that takes in a signal&#39;s <code>file_extension</code> field</li></ul><p>and <code>file_options</code> field and returns the <code>file_format</code> field to be associated with that signal.</p><ul><li><code>kwargs</code> is forwarded to internal invocations of <code>Arrow.write(...; file=true, kwargs...)</code></li></ul><p>used to write the <code>*.arrow</code> files.</p><p>To upgrade a dataset that are older than Onda Format v0.3/v0.4, first use an older version of Onda.jl to upgrade the dataset to Onda Format v0.3 or above.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4d6527be76bbcb102a56f05d6b3e7d144085b582/src/Onda.jl#L38-L74">source</a></section></article></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 28 March 2021 18:24">Sunday 28 March 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
