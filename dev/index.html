<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Documentation · Onda</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Onda</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>API Documentation</a><ul class="internal"><li><a class="tocitem" href="#Dataset-1"><span><code>Dataset</code></span></a></li><li><a class="tocitem" href="#Onda-Metadata-Objects-1"><span>Onda Metadata Objects</span></a></li><li><a class="tocitem" href="#Samples-1"><span><code>Samples</code></span></a></li><li><a class="tocitem" href="#AbstractTimeSpan-1"><span><code>AbstractTimeSpan</code></span></a></li><li><a class="tocitem" href="#Serialization-1"><span>Serialization</span></a></li><li><a class="tocitem" href="#Upgrading-Older-Datasets-to-Newer-Datasets-1"><span>Upgrading Older Datasets to Newer Datasets</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/beacon-biosignals/Onda.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Documentation-1"><a class="docs-heading-anchor" href="#API-Documentation-1">API Documentation</a><a class="docs-heading-anchor-permalink" href="#API-Documentation-1" title="Permalink"></a></h1><p>Below is the documentation for all functions exported by Onda.jl. For general information regarding the Onda format, please see <a href="https://github.com/beacon-biosignals/OndaFormat">beacon-biosignals/OndaFormat</a>.</p><p>Note that Onda.jl&#39;s API follows a specific philosophy with respect to property access: users are generally expected to access fields via Julia&#39;s <code>object.fieldname</code> syntax, but should only <em>mutate</em> objects via the exposed API methods documented below.</p><h2 id="Dataset-1"><a class="docs-heading-anchor" href="#Dataset-1"><code>Dataset</code></a><a class="docs-heading-anchor-permalink" href="#Dataset-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Onda.Dataset" href="#Onda.Dataset"><code>Onda.Dataset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Dataset(path; create=false)</code></pre><p>Return a <code>Dataset</code> instance that contains all metadata necessary to read and write to the Onda dataset stored at <code>path</code>. Note that this constuctor loads all the <code>Recording</code> objects contained in <code>path/recordings.msgpack.zst</code>.</p><p>If <code>create</code> is <code>true</code>, then an empty Onda dataset will be created at <code>path</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/dataset.jl#L11-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.samples_path" href="#Onda.samples_path"><code>Onda.samples_path</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">samples_path(dataset::Dataset, uuid::UUID)</code></pre><p>Return the samples subdirectory path corresponding to the recording specified by <code>uuid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/dataset.jl#L86-L90">source</a></section><section><div><pre><code class="language-none">samples_path(dataset::Dataset, uuid::UUID, name::Symbol,
             file_extension=dataset.recordings[uuid].signals[name].file_extension)</code></pre><p>Return the samples file path corresponding to the signal named <code>name</code> within the recording specified by <code>uuid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/dataset.jl#L93-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.create_recording!" href="#Onda.create_recording!"><code>Onda.create_recording!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">create_recording!(dataset::Dataset, uuid::UUID=uuid4())</code></pre><p>Create <code>uuid::UUID =&gt; recording::Recording</code>, add the pair to <code>dataset.recordings</code>, and return the pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/dataset.jl#L110-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.load" href="#Onda.load"><code>Onda.load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">load(dataset::Dataset, uuid::UUID, name::Symbol[, span::AbstractTimeSpan])</code></pre><p>Load and return the <code>Samples</code> object corresponding to the signal named <code>name</code> in the recording specified by <code>uuid</code>.</p><p>If <code>span</code> is provided, this function returns the equivalent of <code>load(dataset, uuid, name)[:, span]</code>, but potentially avoids loading the entire signal&#39;s worth of sample data if the underlying signal file format supports partial access/random seeks.</p><p>See also: <a href="#Onda.deserialize_lpcm"><code>deserialize_lpcm</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/dataset.jl#L130-L142">source</a></section><section><div><pre><code class="language-none">load(dataset::Dataset, uuid::UUID, names[, span::AbstractTimeSpan])</code></pre><p>Return <code>Dict(name =&gt; load(dataset, uuid, name[, span]) for name in names)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/dataset.jl#L149-L153">source</a></section><section><div><pre><code class="language-none">load(dataset::Dataset, uuid::UUID[, span::AbstractTimeSpan])</code></pre><p>Return <code>load(dataset, uuid, names[, span])</code> where <code>names</code> is a list of all signal names in the recording specified by <code>uuid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/dataset.jl#L158-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.store!" href="#Onda.store!"><code>Onda.store!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">store!(dataset::Dataset, uuid::UUID, name::Symbol, samples::Samples;
       overwrite::Bool=true)</code></pre><p>Add <code>name =&gt; samples.signal</code> to <code>dataset.recordings[uuid].signals</code> and serialize <code>samples.data</code> to the proper file location within <code>dataset.path</code>.</p><p>If <code>overwrite</code> is <code>false</code>, an error is thrown if <code>samples</code> already exists in <code>recording</code>/<code>dataset</code>. Otherwise, existing entries matching <code>samples.signal</code> will be deleted and replaced with <code>samples</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/dataset.jl#L172-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.delete!" href="#Base.delete!"><code>Base.delete!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">delete!(dataset::Dataset, uuid::UUID)</code></pre><p>Delete the recording whose UUID matches <code>uuid</code> from <code>dataset</code>. This function removes the matching <code>Recording</code> object from <code>dataset.recordings</code>, as well as deletes the corresponding subdirectory in the <code>dataset</code>&#39;s <code>samples</code> directory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/dataset.jl#L203-L209">source</a></section><section><div><pre><code class="language-none">delete!(dataset::Dataset, uuid::UUID, name::Symbol)</code></pre><p>Delete the signal whose name matches <code>name</code> from the recording whose UUID matches <code>uuid</code> in <code>dataset</code>. This function removes the matching <code>Signal</code> object from <code>dataset.recordings[uuid]</code>, as well as deletes the corresponding sample data in the <code>dataset</code>&#39;s <code>samples</code> directory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/dataset.jl#L216-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.save_recordings_file" href="#Onda.save_recordings_file"><code>Onda.save_recordings_file</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">save_recordings_file(dataset::Dataset)</code></pre><p>Overwrite <code>joinpath(dataset.path, &quot;recordings.msgpack.zst&quot;)</code> with the contents of <code>dataset.recordings</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/dataset.jl#L40-L45">source</a></section></article><h2 id="Onda-Metadata-Objects-1"><a class="docs-heading-anchor" href="#Onda-Metadata-Objects-1">Onda Metadata Objects</a><a class="docs-heading-anchor-permalink" href="#Onda-Metadata-Objects-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Onda.Signal" href="#Onda.Signal"><code>Onda.Signal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Signal</code></pre><p>A type representing an individual Onda signal object. Instances contain the following fields, following the Onda specification for signal objects:</p><ul><li><code>channel_names::Vector{Symbol}</code></li><li><code>start_nanosecond::Nanosecond</code></li><li><code>stop_nanosecond::Nanosecond</code></li><li><code>sample_unit::Symbol</code></li><li><code>sample_resolution_in_unit::Float64</code></li><li><code>sample_offset_in_unit::Float64</code></li><li><code>sample_type::DataType</code></li><li><code>sample_rate::Float64</code></li><li><code>file_extension::Symbol</code></li><li><code>file_options::Union{Nothing,Dict{Symbol,Any}}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3af96bcefcb0aec559d4652fd75e1bc3fcfe99da/base/#L0-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.signal_from_template" href="#Onda.signal_from_template"><code>Onda.signal_from_template</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">signal_from_template(signal::Signal;
                     channel_names=signal.channel_names,
                     start_nanosecond=signal.start_nanosecond,
                     stop_nanosecond=signal.stop_nanosecond,
                     sample_unit=signal.sample_unit,
                     sample_resolution_in_unit=signal.sample_resolution_in_unit,
                     sample_offset_in_unit=signal.sample_offset_in_unit,
                     sample_type=signal.sample_type,
                     sample_rate=signal.sample_rate,
                     file_extension=signal.file_extension,
                     file_options=signal.file_options)</code></pre><p>Return a <code>Signal</code> where each field is mapped to the corresponding keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/recordings.jl#L142-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.span" href="#Onda.span"><code>Onda.span</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">span(signal::Signal)</code></pre><p>Return <code>TimeSpan(signal.start_nanosecond, signal.stop_nanosecond)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/recordings.jl#L194-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.sizeof_samples" href="#Onda.sizeof_samples"><code>Onda.sizeof_samples</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sizeof_samples(signal::Signal)</code></pre><p>Returns the expected size (in bytes) of the encoded <code>Samples</code> object corresponding to the entirety of <code>signal</code>:</p><pre><code class="language-none">sample_count(signal) * channel_count(signal) * sizeof(signal.sample_type)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/recordings.jl#L216-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.Annotation" href="#Onda.Annotation"><code>Onda.Annotation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Annotation &lt;: AbstractTimeSpan</code></pre><p>A type representing an individual Onda annotation object. Instances contain the following fields, following the Onda specification for annotation objects:</p><ul><li><code>value::String</code></li><li><code>start_nanosecond::Nanosecond</code></li><li><code>stop_nanosecond::Nanosecond</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/recordings.jl#L53-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.Recording" href="#Onda.Recording"><code>Onda.Recording</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Recording</code></pre><p>A type representing an individual Onda recording object. Instances contain the following fields, following the Onda specification for recording objects:</p><ul><li><code>signals::Dict{Symbol,Signal}</code></li><li><code>annotations::Set{Annotation}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/recordings.jl#L230-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.set_span!" href="#Onda.set_span!"><code>Onda.set_span!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_span!(recording::Recording, name::Symbol, span::AbstractTimeSpan)</code></pre><p>Replace <code>recording.signals[name]</code> with a copy that has the <code>start_nanosecond</code> and <code>start_nanosecond</code> fields set to match the provided <code>span</code>. Returns the newly constructed <code>Signal</code> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/recordings.jl#L268-L274">source</a></section><section><div><pre><code class="language-none">set_span!(recording::Recording, span::TimeSpan)</code></pre><p>Return <code>Dict(name =&gt; set_span!(recording, name, span) for name in keys(recording.signals))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/recordings.jl#L283-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.annotate!" href="#Onda.annotate!"><code>Onda.annotate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">annotate!(recording::Recording, annotation::Annotation)</code></pre><p>Returns <code>push!(recording.annotations, annotation)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/recordings.jl#L250-L254">source</a></section></article><h2 id="Samples-1"><a class="docs-heading-anchor" href="#Samples-1"><code>Samples</code></a><a class="docs-heading-anchor-permalink" href="#Samples-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Onda.Samples" href="#Onda.Samples"><code>Onda.Samples</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Samples(signal::Signal, encoded::Bool, data::AbstractMatrix)</code></pre><p>Return a <code>Samples</code> instance with the following fields:</p><ul><li><p><code>signal::Signal</code>: The <code>Signal</code> object that describes the <code>Samples</code> instance.</p></li><li><p><code>encoded::Bool</code>: If <code>true</code>, the values in <code>data</code> are LPCM-encoded as  prescribed by the <code>Samples</code> instance&#39;s <code>signal</code>. If <code>false</code>, the values in  <code>data</code> have been decoded into the <code>signal</code>&#39;s canonical units.</p></li><li><p><code>data::AbstractMatrix</code>: A matrix of sample data. The <code>i</code> th row of the matrix  corresponds to the <code>i</code>th channel in <code>signal.channel_names</code>, while the <code>j</code>th  column corresponds to the <code>j</code>th multichannel sample.</p></li></ul><p>Note that <code>getindex</code> and <code>view</code> are defined on <code>Samples</code> to accept normal integer indices, but also accept channel names for row indices and <a href="#Onda.TimeSpan"><code>TimeSpan</code></a> values for column indices; see <code>Onda/examples/tour.jl</code> for a comprehensive set of indexing examples.</p><p>See also: <a href="#Onda.encode"><code>encode</code></a>, <a href="#Onda.encode!"><code>encode!</code></a>, <a href="#Onda.decode"><code>decode</code></a>, <a href="#Onda.decode!"><code>decode!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/samples.jl#L5-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel" href="#Onda.channel"><code>Onda.channel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">channel(signal::Signal, name::Symbol)</code></pre><p>Return <code>i</code> where <code>signal.channel_names[i] == name</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/recordings.jl#L173-L177">source</a></section><section><div><pre><code class="language-none">channel(signal::Signal, i::Integer)</code></pre><p>Return <code>signal.channel_names[i]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/recordings.jl#L180-L184">source</a></section><section><div><pre><code class="language-none">channel(samples::Samples, name::Symbol)</code></pre><p>Return <code>channel(samples.signal, name)</code>.</p><p>This function is useful for indexing rows of <code>samples.data</code> by channel names.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/samples.jl#L78-L84">source</a></section><section><div><pre><code class="language-none">channel(samples::Samples, i::Integer)</code></pre><p>Return <code>channel(samples.signal, i)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/samples.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel_count" href="#Onda.channel_count"><code>Onda.channel_count</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">channel_count(signal::Signal)</code></pre><p>Return <code>length(signal.channel_names)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/recordings.jl#L187-L191">source</a></section><section><div><pre><code class="language-none">channel_count(samples::Samples)</code></pre><p>Return <code>channel_count(samples.signal)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/samples.jl#L107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.sample_count" href="#Onda.sample_count"><code>Onda.sample_count</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sample_count(signal::Signal)</code></pre><p>Return the number of multichannel samples that fit within <code>duration(signal)</code> given <code>signal.sample_rate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/recordings.jl#L208-L213">source</a></section><section><div><pre><code class="language-none">sample_count(samples::Samples)</code></pre><p>Return the number of multichannel samples in <code>samples</code> (i.e. <code>size(samples.data, 2)</code>)</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>sample_count(samples)</code> is not generally equivalent to <code>sample_count(samples.signal)</code>; the former is the sample count of the entire original signal in the context of its parent recording, whereas the latter is actual number of multichannel samples in <code>samples.data</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/samples.jl#L114-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.encode" href="#Onda.encode"><code>Onda.encode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">encode(sample_type::DataType, sample_resolution_in_unit, sample_offset_in_unit,
       samples, dither_storage=nothing)</code></pre><p>Return a copy of <code>samples</code> quantized according to <code>sample_type</code>, <code>sample_resolution_in_unit</code>, and <code>sample_offset_in_unit</code>. <code>sample_type</code> must be a concrete subtype of <code>Onda.VALID_SAMPLE_TYPE_UNION</code>. Quantization of an individual sample <code>s</code> is performed via:</p><pre><code class="language-none">round(S, (s - sample_offset_in_unit) / sample_resolution_in_unit)</code></pre><p>with additional special casing to clip values exceeding the encoding&#39;s dynamic range.</p><p>If <code>dither_storage isa Nothing</code>, no dithering is applied before quantization.</p><p>If <code>dither_storage isa Missing</code>, dither storage is allocated automatically and triangular dithering is applied to the signal prior to quantization.</p><p>Otherwise, <code>dither_storage</code> must be a container of similar shape and type to <code>samples</code>. This container is then used to store the random noise needed for the triangular dithering process, which is applied to the signal prior to quantization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/samples.jl#L161-L181">source</a></section><section><div><pre><code class="language-none">encode(samples::Samples, dither_storage=nothing)</code></pre><p>If <code>samples.encoded</code> is <code>false</code>, return a <code>Samples</code> instance that wraps:</p><pre><code class="language-none">encode(samples.signal.sample_type,
       samples.signal.sample_resolution_in_unit,
       samples.signal.sample_offset_in_unit,
       samples.data, dither_storage)</code></pre><p>If <code>samples.encoded</code> is <code>true</code>, this function is the identity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/samples.jl#L223-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.encode!" href="#Onda.encode!"><code>Onda.encode!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">encode!(result_storage, sample_type::DataType, sample_resolution_in_unit,
        sample_offset_in_unit, samples, dither_storage=nothing)
encode!(result_storage, sample_resolution_in_unit, sample_offset_in_unit,
        samples, dither_storage=nothing)</code></pre><p>Similar to <code>encode(sample_type, sample_resolution_in_unit, sample_offset_in_unit, samples, dither_storage)</code>, but write encoded values to <code>result_storage</code> rather than allocating new storage.</p><p><code>sample_type</code> defaults to <code>eltype(result_storage)</code> if it is not provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/samples.jl#L188-L198">source</a></section><section><div><pre><code class="language-none">encode!(result_storage, samples::Samples, dither_storage=nothing)</code></pre><p>If <code>samples.encoded</code> is <code>false</code>, return a <code>Samples</code> instance that wraps:</p><pre><code class="language-none">encode!(result_storage,
        samples.signal.sample_type,
        samples.signal.sample_resolution_in_unit,
        samples.signal.sample_offset_in_unit,
        samples.data, dither_storage)`.</code></pre><p>If <code>samples.encoded</code> is <code>true</code>, return a <code>Samples</code> instance that wraps <code>copyto!(result_storage, samples.data)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/samples.jl#L244-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.decode" href="#Onda.decode"><code>Onda.decode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">decode(sample_resolution_in_unit, sample_offset_in_unit, samples)</code></pre><p>Return <code>sample_resolution_in_unit .* samples .+ sample_offset_in_unit</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/samples.jl#L274-L278">source</a></section><section><div><pre><code class="language-none">decode(samples::Samples)</code></pre><p>If <code>samples.encoded</code> is <code>true</code>, return a <code>Samples</code> instance that wraps <code>decode(samples.signal.sample_resolution_in_unit, samples.signal.sample_offset_in_unit, samples.data)</code>.</p><p>If <code>samples.encoded</code> is <code>false</code>, this function is the identity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/samples.jl#L294-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.decode!" href="#Onda.decode!"><code>Onda.decode!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">decode!(result_storage, sample_resolution_in_unit, sample_offset_in_unit, samples)</code></pre><p>Similar to <code>decode(sample_resolution_in_unit, sample_offset_in_unit, samples)</code>, but write decoded values to <code>result_storage</code> rather than allocating new storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/samples.jl#L283-L288">source</a></section><section><div><pre><code class="language-none">decode!(result_storage, samples::Samples)</code></pre><p>If <code>samples.encoded</code> is <code>true</code>, return a <code>Samples</code> instance that wraps <code>decode!(result_storage, samples.signal.sample_resolution_in_unit, samples.signal.sample_offset_in_unit, samples.data)</code>.</p><p>If <code>samples.encoded</code> is <code>false</code>, return a <code>Samples</code> instance that wraps <code>copyto!(result_storage, samples.data)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/samples.jl#L310-L318">source</a></section></article><h2 id="AbstractTimeSpan-1"><a class="docs-heading-anchor" href="#AbstractTimeSpan-1"><code>AbstractTimeSpan</code></a><a class="docs-heading-anchor-permalink" href="#AbstractTimeSpan-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Onda.AbstractTimeSpan" href="#Onda.AbstractTimeSpan"><code>Onda.AbstractTimeSpan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractTimeSpan</code></pre><p>A type repesenting a continuous, inclusive span between two points in time.</p><p>All subtypes of <code>AbstractTimeSpan</code> must implement:</p><ul><li><code>first(::AbstractTimeSpan)::Nanosecond</code>: return the first nanosecond contained in <code>span</code></li><li><code>last(::AbstractTimeSpan)::Nanosecond</code>: return the last nanosecond contained in <code>span</code></li></ul><p>For convenience, many Onda functions that accept <code>AbstractTimeSpan</code> values also accept <code>Dates.Period</code> values.</p><p>See also: <a href="#Onda.TimeSpan"><code>TimeSpan</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/timespans.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.TimeSpan" href="#Onda.TimeSpan"><code>Onda.TimeSpan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TimeSpan(first, last)</code></pre><p>Return <code>TimeSpan(Nanosecond(first), Nanosecond(last))::AbstractTimeSpan</code>.</p><p>See also: <a href="#Onda.AbstractTimeSpan"><code>AbstractTimeSpan</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/timespans.jl#L33-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.contains" href="#Onda.contains"><code>Onda.contains</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">contains(a, b)</code></pre><p>Return <code>true</code> if the timespan <code>b</code> lies entirely within the timespan <code>a</code>, return <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/timespans.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.overlaps" href="#Onda.overlaps"><code>Onda.overlaps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">overlaps(a, b)</code></pre><p>Return <code>true</code> if the timespan <code>a</code> and the timespan <code>b</code> overlap, return <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/timespans.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.shortest_timespan_containing" href="#Onda.shortest_timespan_containing"><code>Onda.shortest_timespan_containing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">shortest_timespan_containing(spans)</code></pre><p>Return the shortest possible <code>TimeSpan</code> containing all timespans in <code>spans</code>.</p><p><code>spans</code> is assumed to be an iterable of timespans.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/timespans.jl#L88-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.duration" href="#Onda.duration"><code>Onda.duration</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">duration(span)</code></pre><p>Return the duration of <code>span</code> as a <code>Period</code>.</p><p>For <code>span::AbstractTimeSpan</code>, this is equivalent to <code>last(span) - first(span)</code>.</p><p>For <code>span::Period</code>, this function is the identity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/timespans.jl#L105-L113">source</a></section><section><div><pre><code class="language-none">duration(signal::Signal)</code></pre><p>Return <code>duration(span(signal))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/recordings.jl#L201-L205">source</a></section><section><div><pre><code class="language-none">duration(recording::Recording)</code></pre><p>Returns <code>maximum(s -&gt; s.stop_nanosecond, values(recording.signals))</code>; throws an <code>ArgumentError</code> if <code>recording.signals</code> is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/recordings.jl#L257-L262">source</a></section><section><div><pre><code class="language-none">duration(samples::Samples)</code></pre><p>Returns the <code>Nanosecond</code> value for which <code>samples[TimeSpan(0, duration(samples))] == samples.data</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>duration(samples)</code> is not generally equivalent to <code>duration(samples.signal)</code>; the former is the duration of the entire original signal in the context of its parent recording, whereas the latter is the actual duration of <code>samples.data</code> given <code>samples.signal.sample_rate</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/samples.jl#L94-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.time_from_index" href="#Onda.time_from_index"><code>Onda.time_from_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">time_from_index(sample_rate, sample_index)</code></pre><p>Given <code>sample_rate</code> in Hz and assuming <code>sample_index &gt; 0</code>, return the earliest <code>Nanosecond</code> containing <code>sample_index</code>.</p><p>Examples:</p><pre><code class="language-none">julia&gt; time_from_index(1, 1)
0 nanoseconds

julia&gt; time_from_index(1, 2)
1000000000 nanoseconds

julia&gt; time_from_index(100, 100)
990000000 nanoseconds

julia&gt; time_from_index(100, 101)
1000000000 nanoseconds</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/timespans.jl#L172-L193">source</a></section><section><div><pre><code class="language-none">time_from_index(sample_rate, sample_range::AbstractUnitRange)</code></pre><p>Return the <code>TimeSpan</code> corresponding to <code>sample_range</code> given <code>sample_rate</code> in Hz:</p><pre><code class="language-none">julia&gt; time_from_index(100, 1:100)
TimeSpan(0 nanoseconds, 1000000000 nanoseconds)

julia&gt; time_from_index(100, 101:101)
TimeSpan(1000000000 nanoseconds, 1000000000 nanoseconds)

julia&gt; time_from_index(100, 301:600)
TimeSpan(3000000000 nanoseconds, 6000000000 nanoseconds)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/timespans.jl#L199-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.index_from_time" href="#Onda.index_from_time"><code>Onda.index_from_time</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">index_from_time(sample_rate, sample_time)</code></pre><p>Given <code>sample_rate</code> in Hz, return the integer index of the most recent sample taken at <code>sample_time</code>. Note that <code>sample_time</code> must be non-negative and support <code>convert(Nanosecond, sample_time)</code>.</p><p>Examples:</p><pre><code class="language-none">julia&gt; index_from_time(1, Second(0))
1

julia&gt; index_from_time(1, Second(1))
2

julia&gt; index_from_time(100, Millisecond(999))
100

julia&gt; index_from_time(100, Millisecond(1000))
101</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/timespans.jl#L119-L141">source</a></section><section><div><pre><code class="language-none">index_from_time(sample_rate, span::AbstractTimeSpan)</code></pre><p>Return the <code>UnitRange</code> of indices corresponding to <code>span</code> given <code>sample_rate</code> in Hz:</p><pre><code class="language-none">julia&gt; index_from_time(100, TimeSpan(Second(0), Second(1)))
1:100

julia&gt; index_from_time(100, TimeSpan(Second(1), Second(1)))
101:101

julia&gt; index_from_time(100, TimeSpan(Second(3), Second(6)))
301:600</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/timespans.jl#L149-L164">source</a></section></article><h2 id="Serialization-1"><a class="docs-heading-anchor" href="#Serialization-1">Serialization</a><a class="docs-heading-anchor-permalink" href="#Serialization-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Onda.AbstractLPCMSerializer" href="#Onda.AbstractLPCMSerializer"><code>Onda.AbstractLPCMSerializer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractLPCMSerializer</code></pre><p>A type whose subtypes support:</p><ul><li><a href="#Onda.deserialize_lpcm"><code>deserialize_lpcm</code></a></li><li><a href="#Onda.serialize_lpcm"><code>serialize_lpcm</code></a></li></ul><p>All definitions of subtypes of the form <code>S&lt;:AbstractLPCMSerializer</code> must also support a constructor of the form <code>S(::Signal)</code> and overload <code>Onda.serializer_constructor_for_file_extension</code> with the appropriate file extension.</p><p>See also: <a href="#Onda.serializer"><code>serializer</code></a>, <a href="#Onda.LPCM"><code>LPCM</code></a>, <a href="#Onda.LPCMZst"><code>LPCMZst</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/serialization.jl#L5-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.serializer_constructor_for_file_extension" href="#Onda.serializer_constructor_for_file_extension"><code>Onda.serializer_constructor_for_file_extension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Onda.serializer_constructor_for_file_extension(::Val{:extension_symbol})</code></pre><p>Return a constructor of the form <code>S(::Signal)::AbstractLPCMSerializer</code> corresponding to the provided extension.</p><p>This function should be overloaded for new <code>AbstractLPCMSerializer</code> subtypes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/serialization.jl#L21-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.serializer" href="#Onda.serializer"><code>Onda.serializer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">serializer(signal::Signal; kwargs...)</code></pre><p>Return <code>S(signal; kwargs...)</code> where <code>S</code> is the <code>AbstractLPCMSerializer</code> that corresponds to <code>signal.file_extension</code> (as determined by the serializer author via <code>serializer_constructor_for_file_extension</code>).</p><p>See also: <a href="#Onda.deserialize_lpcm"><code>deserialize_lpcm</code></a>, <a href="#Onda.serialize_lpcm"><code>serialize_lpcm</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/serialization.jl#L40-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.deserialize_lpcm" href="#Onda.deserialize_lpcm"><code>Onda.deserialize_lpcm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">deserialize_lpcm(bytes, serializer::AbstractLPCMSerializer)</code></pre><p>Return a channels-by-timesteps <code>AbstractMatrix</code> of interleaved LPCM-encoded sample data by deserializing the provided <code>bytes</code> from the given <code>serializer</code>.</p><p>Note that this operation may be performed in a zero-copy manner such that the returned sample matrix directly aliases <code>bytes</code>.</p><p>This function is the inverse of the corresponding <a href="#Onda.serialize_lpcm"><code>serialize_lpcm</code></a> method, i.e.:</p><pre><code class="language-none">serialize_lpcm(deserialize_lpcm(bytes, serializer), serializer) == bytes</code></pre><pre><code class="language-none">deserialize_lpcm(bytes, serializer::AbstractLPCMSerializer, sample_offset, sample_count)</code></pre><p>Similar to <code>deserialize_lpcm(bytes, serializer)</code>, but deserialize only the segment requested via <code>sample_offset</code> and <code>sample_count</code>.</p><pre><code class="language-none">deserialize_lpcm(io::IO, serializer::AbstractLPCMSerializer[, sample_offset, sample_count])</code></pre><p>Similar to the corresponding <code>deserialize_lpcm(bytes, ...)</code> methods, but the bytes to be deserialized are read directly from <code>io</code>.</p><p>If <code>sample_offset</code>/<code>sample_count</code> is provided and <code>io</code>/<code>serializer</code> support seeking, implementations of this method may read only the bytes required to extract the requested segment instead of reading the entire stream.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/serialization.jl#L54-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.serialize_lpcm" href="#Onda.serialize_lpcm"><code>Onda.serialize_lpcm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">serialize_lpcm(samples::AbstractMatrix, serializer::AbstractLPCMSerializer)</code></pre><p>Return the <code>AbstractVector{UInt8}</code> of bytes that results from serializing <code>samples</code> to the given <code>serializer</code>, where <code>samples</code> is a channels-by-timesteps matrix of interleaved LPCM-encoded sample data.</p><p>Note that this operation may be performed in a zero-copy manner such that the returned <code>AbstractVector{UInt8}</code> directly aliases <code>samples</code>.</p><p>This function is the inverse of the corresponding <a href="#Onda.deserialize_lpcm"><code>deserialize_lpcm</code></a> method, i.e.:</p><pre><code class="language-none">deserialize_lpcm(serialize_lpcm(samples, serializer), serializer) == samples</code></pre><pre><code class="language-none">serialize_lpcm(io::IO, samples::AbstractMatrix, serializer::AbstractLPCMSerializer)</code></pre><p>Similar to the corresponding <code>serialize_lpcm(samples, serializer)</code> method, but serializes directly to <code>io</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/serialization.jl#L86-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.LPCM" href="#Onda.LPCM"><code>Onda.LPCM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LPCM{S}(channel_count)
LPCM(signal::Signal)</code></pre><p>Return a <code>LPCM&lt;:AbstractLPCMSerializer</code> instance corresponding to Onda&#39;s default interleaved LPCM format assumed for signal files with the &quot;.lpcm&quot; extension.</p><p><code>S</code> corresponds to <code>signal.sample_type</code>, while <code>channel_count</code> corresponds to <code>signal.channel_names</code>.</p><p>Note that bytes (de)serialized via this serializer are little-endian per the Onda specification.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/serialization.jl#L137-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.LPCMZst" href="#Onda.LPCMZst"><code>Onda.LPCMZst</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LPCMZst(lpcm::LPCM; level=3)
LPCMZst(signal::Signal; level=3)</code></pre><p>Return a <code>LPCMZst&lt;:AbstractLPCMSerializer</code> instance that corresponds to Onda&#39;s default interleaved LPCM format compressed by <code>zstd</code>. This serializer is assumed for signal files with the &quot;.lpcm.zst&quot; extension.</p><p>The <code>level</code> keyword argument sets the same compression level parameter as the corresponding flag documented by the <code>zstd</code> command line utility.</p><p>See https://facebook.github.io/zstd/ for details about <code>zstd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/serialization.jl#L196-L208">source</a></section></article><h2 id="Upgrading-Older-Datasets-to-Newer-Datasets-1"><a class="docs-heading-anchor" href="#Upgrading-Older-Datasets-to-Newer-Datasets-1">Upgrading Older Datasets to Newer Datasets</a><a class="docs-heading-anchor-permalink" href="#Upgrading-Older-Datasets-to-Newer-Datasets-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Onda.upgrade_onda_format_from_v0_2_to_v0_3!" href="#Onda.upgrade_onda_format_from_v0_2_to_v0_3!"><code>Onda.upgrade_onda_format_from_v0_2_to_v0_3!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Onda.upgrade_onda_format_from_v0_2_to_v0_3!(path, combine_annotation_key_value)</code></pre><p>Upgrade the Onda v0.2 dataset at <code>path</code> to a Onda v0.3 dataset, returning the upgraded <code>Dataset</code>. This upgrade process overwrites <code>path/recordings.msgpack.zst</code> with a v0.3-compliant version of this file; for safety&#39;s sake, the old v0.2 file is preserved at <code>path/old.recordings.msgpack.zst.backup</code>.</p><p>A couple of the Onda v0.2 -&gt; v0.3 changes require some special handling:</p><ul><li><p>The <code>custom</code> field was removed from recording objects. This function thus writes out a file at <code>path/recordings_custom.msgpack.zst</code> that contains a map of UUIDs to corresponding recordings&#39; <code>custom</code> values before deleting the <code>custom</code> field. This file can be deserialized via <code>MsgPack.unpack(Onda.zstd_decompress(read(&quot;recordings_custom.msgpack.zst&quot;)))</code>.</p></li><li><p>Annotations no longer have a <code>key</code> field. Thus, each annotation&#39;s existing <code>key</code> and <code>value</code> fields are combined into the single new <code>value</code> field via the provided callback <code>combine_annotation_key_value(annotation_key, annotation_value)</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/b448b0f818769dc0f2a1cbfd723befe7f3352f98/src/Onda.jl#L97-L115">source</a></section></article></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 8 April 2020 20:29">Wednesday 8 April 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
