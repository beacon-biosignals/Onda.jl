<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Documentation · Onda</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Onda</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>API Documentation</a><ul class="internal"><li><a class="tocitem" href="#Dataset-API-1"><span><code>Dataset</code> API</span></a></li><li><a class="tocitem" href="#Onda-Format-Metadata-1"><span>Onda Format Metadata</span></a></li><li><a class="tocitem" href="#Samples-1"><span><code>Samples</code></span></a></li><li><a class="tocitem" href="#AbstractTimeSpan-1"><span><code>AbstractTimeSpan</code></span></a></li><li><a class="tocitem" href="#Paths-API-1"><span>Paths API</span></a></li><li><a class="tocitem" href="#Serialization-API-1"><span>Serialization API</span></a></li><li><a class="tocitem" href="#Upgrading-Older-Datasets-to-Newer-Datasets-1"><span>Upgrading Older Datasets to Newer Datasets</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/beacon-biosignals/Onda.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Documentation-1"><a class="docs-heading-anchor" href="#API-Documentation-1">API Documentation</a><a class="docs-heading-anchor-permalink" href="#API-Documentation-1" title="Permalink"></a></h1><p>Below is the documentation for all functions exported by Onda.jl. For general information regarding the Onda format, please see <a href="https://github.com/beacon-biosignals/OndaFormat">beacon-biosignals/OndaFormat</a>.</p><p>Note that Onda.jl&#39;s API follows a specific philosophy with respect to property access: users are generally expected to access fields via Julia&#39;s <code>object.fieldname</code> syntax, but should only <em>mutate</em> objects via the exposed API methods documented below.</p><h2 id="Dataset-API-1"><a class="docs-heading-anchor" href="#Dataset-API-1"><code>Dataset</code> API</a><a class="docs-heading-anchor-permalink" href="#Dataset-API-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Onda.Dataset" href="#Onda.Dataset"><code>Onda.Dataset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Dataset(path)</code></pre><p>Return a <code>Dataset</code> instance targeting <code>path</code> as an Onda dataset, without loading any content from <code>path</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/dataset.jl#L18-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.load" href="#Onda.load"><code>Onda.load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">load(path)</code></pre><p>Return a <code>Dataset</code> instance that contains all metadata necessary to read and write to the Onda dataset stored at <code>path</code>. Note that this constuctor loads all the <code>Recording</code> objects contained in <code>path/recordings.msgpack.zst</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/dataset.jl#L37-L43">source</a></section><section><div><pre><code class="language-none">load(dataset::Dataset, uuid::UUID, signal_name::Symbol[, span::AbstractTimeSpan])</code></pre><p>Load and return the <code>Samples</code> object corresponding to the signal named <code>signal_name</code> in the recording specified by <code>uuid</code>.</p><p>If <code>span</code> is provided, this function returns the equivalent of <code>load(dataset, uuid, signal_name)[:, span]</code>, but potentially avoids loading the entire signal&#39;s worth of sample data if the underlying signal file format and target storage layer both support partial access/random seeks.</p><p>See also: <a href="#Onda.read_samples"><code>read_samples</code></a>, <a href="#Onda.deserialize_lpcm"><code>deserialize_lpcm</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/dataset.jl#L143-L155">source</a></section><section><div><pre><code class="language-none">load(dataset::Dataset, uuid::UUID, signal_names[, span::AbstractTimeSpan])</code></pre><p>Return <code>Dict(signal_name =&gt; load(dataset, uuid, signal_name[, span]) for signal_name in signal_names)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/dataset.jl#L162-L166">source</a></section><section><div><pre><code class="language-none">load(dataset::Dataset, uuid::UUID[, span::AbstractTimeSpan])</code></pre><p>Return <code>load(dataset, uuid, names[, span])</code> where <code>names</code> is a list of all signal names in the recording specified by <code>uuid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/dataset.jl#L172-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.save" href="#Onda.save"><code>Onda.save</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">save(dataset::Dataset)</code></pre><p>Save all metadata content necessary to read/write <code>dataset</code> to <code>dataset.path</code>.</p><p>Note that in-memory mutations to <code>dataset</code> will not persist unless followed by a <code>save</code> call. Furthermore, new sample data written to <code>dataset</code> via <code>store!</code> will not be readable from freshly loaded copies of <code>dataset</code> (e.g. <code>load(dataset.path)</code>) until <code>save</code> is called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/dataset.jl#L49-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.create_recording!" href="#Onda.create_recording!"><code>Onda.create_recording!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">create_recording!(dataset::Dataset, uuid::UUID=uuid4())</code></pre><p>Create <code>uuid::UUID =&gt; recording::Recording</code>, add the pair to <code>dataset.recordings</code>, and return the pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/dataset.jl#L102-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.store!" href="#Onda.store!"><code>Onda.store!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">store!(dataset::Dataset, uuid::UUID, signal_name::Symbol, samples::Samples;
       overwrite::Bool=true)</code></pre><p>Add <code>signal_name =&gt; samples.signal</code> to <code>dataset.recordings[uuid].signals</code> and serialize <code>samples.data</code> to the proper file path within <code>dataset.path</code>.</p><p>If <code>overwrite</code> is <code>false</code>, an error is thrown if a signal with <code>signal_name</code> already exists in <code>dataset.recordings[uuid]</code>. Otherwise, existing entries matching <code>samples.signal</code> will be deleted and replaced with <code>samples</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/dataset.jl#L186-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.delete!" href="#Base.delete!"><code>Base.delete!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">delete!(dataset::Dataset, uuid::UUID)</code></pre><p>Delete the recording whose UUID matches <code>uuid</code> from <code>dataset</code>. This function removes the matching <code>Recording</code> object from <code>dataset.recordings</code>, as well as deletes the corresponding subdirectory in the <code>dataset</code>&#39;s <code>samples</code> directory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/dataset.jl#L218-L224">source</a></section><section><div><pre><code class="language-none">delete!(dataset::Dataset, uuid::UUID, signal_name::Symbol)</code></pre><p>Delete the signal whose signal<em>name matches `signal</em>name<code>from the recording whose UUID matches</code>uuid<code>in</code>dataset<code>. This function removes the matching</code>Signal<code>object from</code>dataset.recordings[uuid]<code>, as well as deletes the corresponding sample data in the</code>dataset<code>&#39;s</code>samples` directory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/dataset.jl#L231-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.validate_on_construction" href="#Onda.validate_on_construction"><code>Onda.validate_on_construction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Onda.validate_on_construction()</code></pre><p>If this function returns <code>true</code>, Onda objects will be validated upon construction for compliance with the Onda specification.</p><p>If this function returns <code>false</code>, no such validation will be performed upon construction.</p><p>Users may interactively redefine this method in order to attempt to read malformed Onda datasets.</p><p>Returns <code>true</code> by default.</p><p>See also: <a href="#Onda.validate_signal"><code>validate_signal</code></a>, <a href="#Onda.validate_samples"><code>validate_samples</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/utilities.jl#L5-L19">source</a></section></article><h2 id="Onda-Format-Metadata-1"><a class="docs-heading-anchor" href="#Onda-Format-Metadata-1">Onda Format Metadata</a><a class="docs-heading-anchor-permalink" href="#Onda-Format-Metadata-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Onda.Signal" href="#Onda.Signal"><code>Onda.Signal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Signal</code></pre><p>A type representing an individual Onda signal object. Instances contain the following fields, following the Onda specification for signal objects:</p><ul><li><code>channel_names::Vector{Symbol}</code></li><li><code>start_nanosecond::Nanosecond</code></li><li><code>stop_nanosecond::Nanosecond</code></li><li><code>sample_unit::Symbol</code></li><li><code>sample_resolution_in_unit::Float64</code></li><li><code>sample_offset_in_unit::Float64</code></li><li><code>sample_type::DataType</code></li><li><code>sample_rate::Float64</code></li><li><code>file_extension::Symbol</code></li><li><code>file_options::Union{Nothing,Dict{Symbol,Any}}</code></li></ul><p>If <a href="#Onda.validate_on_construction"><code>validate_on_construction</code></a> returns <code>true</code>, <a href="#Onda.validate_signal"><code>validate_signal</code></a> is called on all new <code>Signal</code> instances upon construction.</p><p>Similarly to the <a href="#Onda.TimeSpan"><code>TimeSpan</code></a> constructor, this constructor will add a single <code>Nanosecond</code> to <code>stop_nanosecond</code> if <code>start_nanosecond == stop_nanosecond</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3af96bcefcb0aec559d4652fd75e1bc3fcfe99da/base/#L0-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.validate_signal" href="#Onda.validate_signal"><code>Onda.validate_signal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">validate_signal(signal::Signal)</code></pre><p>Returns <code>nothing</code>, checking that the given <code>signal</code> is valid w.r.t. the Onda specification. If a violation is found, an <code>ArgumentError</code> is thrown.</p><p>Properties that are validated by this function include:</p><ul><li><code>sample_type</code> is a valid Onda sample type</li><li><code>sample_unit</code> name is lowercase, snakecase, and alphanumeric</li><li><code>start_nanosecond</code>/<code>stop_nanosecond</code> form a valid time span</li><li>channel names are lowercase, snakecase, and alphanumeric</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/recordings.jl#L141-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.signal_from_template" href="#Onda.signal_from_template"><code>Onda.signal_from_template</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">signal_from_template(signal::Signal;
                     channel_names=signal.channel_names,
                     start_nanosecond=signal.start_nanosecond,
                     stop_nanosecond=signal.stop_nanosecond,
                     sample_unit=signal.sample_unit,
                     sample_resolution_in_unit=signal.sample_resolution_in_unit,
                     sample_offset_in_unit=signal.sample_offset_in_unit,
                     sample_type=signal.sample_type,
                     sample_rate=signal.sample_rate,
                     file_extension=signal.file_extension,
                     file_options=signal.file_options,
                     validate=Onda.validate_on_construction())</code></pre><p>Return a <code>Signal</code> where each field is mapped to the corresponding keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/recordings.jl#L175-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.span" href="#Onda.span"><code>Onda.span</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">span(signal::Signal)</code></pre><p>Return <code>TimeSpan(signal.start_nanosecond, signal.stop_nanosecond)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/recordings.jl#L229-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.sizeof_samples" href="#Onda.sizeof_samples"><code>Onda.sizeof_samples</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sizeof_samples(signal::Signal)</code></pre><p>Returns the expected size (in bytes) of the encoded <code>Samples</code> object corresponding to the entirety of <code>signal</code>:</p><pre><code class="language-none">sample_count(signal) * channel_count(signal) * sizeof(signal.sample_type)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/recordings.jl#L251-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.Annotation" href="#Onda.Annotation"><code>Onda.Annotation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Annotation &lt;: AbstractTimeSpan</code></pre><p>A type representing an individual Onda annotation object. Instances contain the following fields, following the Onda specification for annotation objects:</p><ul><li><code>value::String</code></li><li><code>start_nanosecond::Nanosecond</code></li><li><code>stop_nanosecond::Nanosecond</code></li></ul><p>Similarly to the <a href="#Onda.TimeSpan"><code>TimeSpan</code></a> constructor, this constructor will add a single <code>Nanosecond</code> to <code>stop_nanosecond</code> if <code>start_nanosecond == stop_nanosecond</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/recordings.jl#L53-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.Recording" href="#Onda.Recording"><code>Onda.Recording</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Recording</code></pre><p>A type representing an individual Onda recording object. Instances contain the following fields, following the Onda specification for recording objects:</p><ul><li><code>signals::Dict{Symbol,Signal}</code></li><li><code>annotations::Set{Annotation}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/recordings.jl#L265-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.set_span!" href="#Onda.set_span!"><code>Onda.set_span!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_span!(recording::Recording, name::Symbol, span::AbstractTimeSpan)</code></pre><p>Replace <code>recording.signals[name]</code> with a copy that has the <code>start_nanosecond</code> and <code>start_nanosecond</code> fields set to match the provided <code>span</code>. Returns the newly constructed <code>Signal</code> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/recordings.jl#L303-L309">source</a></section><section><div><pre><code class="language-none">set_span!(recording::Recording, span::TimeSpan)</code></pre><p>Return <code>Dict(name =&gt; set_span!(recording, name, span) for name in keys(recording.signals))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/recordings.jl#L318-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.annotate!" href="#Onda.annotate!"><code>Onda.annotate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">annotate!(recording::Recording, annotation::Annotation)</code></pre><p>Returns <code>push!(recording.annotations, annotation)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/recordings.jl#L285-L289">source</a></section></article><h2 id="Samples-1"><a class="docs-heading-anchor" href="#Samples-1"><code>Samples</code></a><a class="docs-heading-anchor-permalink" href="#Samples-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Onda.Samples" href="#Onda.Samples"><code>Onda.Samples</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Samples(signal::Signal, encoded::Bool, data::AbstractMatrix,
        validate::Bool=Onda.validate_on_construction())</code></pre><p>Return a <code>Samples</code> instance with the following fields:</p><ul><li><p><code>signal::Signal</code>: The <code>Signal</code> object that describes the <code>Samples</code> instance.</p></li><li><p><code>encoded::Bool</code>: If <code>true</code>, the values in <code>data</code> are LPCM-encoded as  prescribed by the <code>Samples</code> instance&#39;s <code>signal</code>. If <code>false</code>, the values in  <code>data</code> have been decoded into the <code>signal</code>&#39;s canonical units.</p></li><li><p><code>data::AbstractMatrix</code>: A matrix of sample data. The <code>i</code> th row of the matrix  corresponds to the <code>i</code>th channel in <code>signal.channel_names</code>, while the <code>j</code>th  column corresponds to the <code>j</code>th multichannel sample.</p></li><li><p><code>validate::Bool</code>: If <code>true</code>, <a href="#Onda.validate_samples"><code>validate_samples</code></a> is called on the constructed  <code>Samples</code> instance before it is returned.</p></li></ul><p>Note that <code>getindex</code> and <code>view</code> are defined on <code>Samples</code> to accept normal integer indices, but also accept channel names for row indices and <a href="#Onda.TimeSpan"><code>TimeSpan</code></a> values for column indices; see <code>Onda/examples/tour.jl</code> for a comprehensive set of indexing examples.</p><p>See also: <a href="#Onda.encode"><code>encode</code></a>, <a href="#Onda.encode!"><code>encode!</code></a>, <a href="#Onda.decode"><code>decode</code></a>, <a href="#Onda.decode!"><code>decode!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/samples.jl#L5-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.validate_samples" href="#Onda.validate_samples"><code>Onda.validate_samples</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">validate_samples(samples::Samples)</code></pre><p>Returns <code>nothing</code>, checking that the given <code>samples</code> are valid w.r.t. the underlying <code>samples.signal</code> and the Onda specification&#39;s canonical LPCM representation. If a violation is found, an <code>ArgumentError</code> is thrown.</p><p>Properties that are validated by this function include:</p><ul><li>encoded element type matches <code>samples.signal.sample_type</code></li><li>the number of rows of <code>samples.data</code> matches the number of channels in <code>samples.signal</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/samples.jl#L43-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel" href="#Onda.channel"><code>Onda.channel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">channel(signal::Signal, name::Symbol)</code></pre><p>Return <code>i</code> where <code>signal.channel_names[i] == name</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/recordings.jl#L208-L212">source</a></section><section><div><pre><code class="language-none">channel(signal::Signal, i::Integer)</code></pre><p>Return <code>signal.channel_names[i]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/recordings.jl#L215-L219">source</a></section><section><div><pre><code class="language-none">channel(samples::Samples, name::Symbol)</code></pre><p>Return <code>channel(samples.signal, name)</code>.</p><p>This function is useful for indexing rows of <code>samples.data</code> by channel names.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/samples.jl#L103-L109">source</a></section><section><div><pre><code class="language-none">channel(samples::Samples, i::Integer)</code></pre><p>Return <code>channel(samples.signal, i)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/samples.jl#L112-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel_count" href="#Onda.channel_count"><code>Onda.channel_count</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">channel_count(signal::Signal)</code></pre><p>Return <code>length(signal.channel_names)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/recordings.jl#L222-L226">source</a></section><section><div><pre><code class="language-none">channel_count(samples::Samples)</code></pre><p>Return <code>channel_count(samples.signal)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/samples.jl#L132-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.sample_count" href="#Onda.sample_count"><code>Onda.sample_count</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sample_count(signal::Signal)</code></pre><p>Return the number of multichannel samples that fit within <code>duration(signal)</code> given <code>signal.sample_rate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/recordings.jl#L243-L248">source</a></section><section><div><pre><code class="language-none">sample_count(samples::Samples)</code></pre><p>Return the number of multichannel samples in <code>samples</code> (i.e. <code>size(samples.data, 2)</code>)</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>sample_count(samples)</code> is not generally equivalent to <code>sample_count(samples.signal)</code>; the former is the sample count of the entire original signal in the context of its parent recording, whereas the latter is actual number of multichannel samples in <code>samples.data</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/samples.jl#L139-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.encode" href="#Onda.encode"><code>Onda.encode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">encode(sample_type::DataType, sample_resolution_in_unit, sample_offset_in_unit,
       samples, dither_storage=nothing)</code></pre><p>Return a copy of <code>samples</code> quantized according to <code>sample_type</code>, <code>sample_resolution_in_unit</code>, and <code>sample_offset_in_unit</code>. <code>sample_type</code> must be a concrete subtype of <code>Onda.VALID_SAMPLE_TYPE_UNION</code>. Quantization of an individual sample <code>s</code> is performed via:</p><pre><code class="language-none">round(S, (s - sample_offset_in_unit) / sample_resolution_in_unit)</code></pre><p>with additional special casing to clip values exceeding the encoding&#39;s dynamic range.</p><p>If <code>dither_storage isa Nothing</code>, no dithering is applied before quantization.</p><p>If <code>dither_storage isa Missing</code>, dither storage is allocated automatically and triangular dithering is applied to the signal prior to quantization.</p><p>Otherwise, <code>dither_storage</code> must be a container of similar shape and type to <code>samples</code>. This container is then used to store the random noise needed for the triangular dithering process, which is applied to the signal prior to quantization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/samples.jl#L186-L206">source</a></section><section><div><pre><code class="language-none">encode(samples::Samples, dither_storage=nothing)</code></pre><p>If <code>samples.encoded</code> is <code>false</code>, return a <code>Samples</code> instance that wraps:</p><pre><code class="language-none">encode(samples.signal.sample_type,
       samples.signal.sample_resolution_in_unit,
       samples.signal.sample_offset_in_unit,
       samples.data, dither_storage)</code></pre><p>If <code>samples.encoded</code> is <code>true</code>, this function is the identity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/samples.jl#L248-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.encode!" href="#Onda.encode!"><code>Onda.encode!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">encode!(result_storage, sample_type::DataType, sample_resolution_in_unit,
        sample_offset_in_unit, samples, dither_storage=nothing)
encode!(result_storage, sample_resolution_in_unit, sample_offset_in_unit,
        samples, dither_storage=nothing)</code></pre><p>Similar to <code>encode(sample_type, sample_resolution_in_unit, sample_offset_in_unit, samples, dither_storage)</code>, but write encoded values to <code>result_storage</code> rather than allocating new storage.</p><p><code>sample_type</code> defaults to <code>eltype(result_storage)</code> if it is not provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/samples.jl#L213-L223">source</a></section><section><div><pre><code class="language-none">encode!(result_storage, samples::Samples, dither_storage=nothing)</code></pre><p>If <code>samples.encoded</code> is <code>false</code>, return a <code>Samples</code> instance that wraps:</p><pre><code class="language-none">encode!(result_storage,
        samples.signal.sample_type,
        samples.signal.sample_resolution_in_unit,
        samples.signal.sample_offset_in_unit,
        samples.data, dither_storage)`.</code></pre><p>If <code>samples.encoded</code> is <code>true</code>, return a <code>Samples</code> instance that wraps <code>copyto!(result_storage, samples.data)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/samples.jl#L269-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.decode" href="#Onda.decode"><code>Onda.decode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">decode(sample_resolution_in_unit, sample_offset_in_unit, samples)</code></pre><p>Return <code>sample_resolution_in_unit .* samples .+ sample_offset_in_unit</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/samples.jl#L299-L303">source</a></section><section><div><pre><code class="language-none">decode(samples::Samples)</code></pre><p>If <code>samples.encoded</code> is <code>true</code>, return a <code>Samples</code> instance that wraps <code>decode(samples.signal.sample_resolution_in_unit, samples.signal.sample_offset_in_unit, samples.data)</code>.</p><p>If <code>samples.encoded</code> is <code>false</code>, this function is the identity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/samples.jl#L319-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.decode!" href="#Onda.decode!"><code>Onda.decode!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">decode!(result_storage, sample_resolution_in_unit, sample_offset_in_unit, samples)</code></pre><p>Similar to <code>decode(sample_resolution_in_unit, sample_offset_in_unit, samples)</code>, but write decoded values to <code>result_storage</code> rather than allocating new storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/samples.jl#L308-L313">source</a></section><section><div><pre><code class="language-none">decode!(result_storage, samples::Samples)</code></pre><p>If <code>samples.encoded</code> is <code>true</code>, return a <code>Samples</code> instance that wraps <code>decode!(result_storage, samples.signal.sample_resolution_in_unit, samples.signal.sample_offset_in_unit, samples.data)</code>.</p><p>If <code>samples.encoded</code> is <code>false</code>, return a <code>Samples</code> instance that wraps <code>copyto!(result_storage, samples.data)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/samples.jl#L335-L343">source</a></section></article><h2 id="AbstractTimeSpan-1"><a class="docs-heading-anchor" href="#AbstractTimeSpan-1"><code>AbstractTimeSpan</code></a><a class="docs-heading-anchor-permalink" href="#AbstractTimeSpan-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Onda.AbstractTimeSpan" href="#Onda.AbstractTimeSpan"><code>Onda.AbstractTimeSpan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractTimeSpan</code></pre><p>A type repesenting a continuous, inclusive span between two points in time.</p><p>All subtypes of <code>AbstractTimeSpan</code> must implement:</p><ul><li><code>first(::AbstractTimeSpan)::Nanosecond</code>: return the first nanosecond contained in <code>span</code></li><li><code>last(::AbstractTimeSpan)::Nanosecond</code>: return the last nanosecond contained in <code>span</code></li></ul><p>For convenience, many Onda functions that accept <code>AbstractTimeSpan</code> values also accept <code>Dates.Period</code> values.</p><p>See also: <a href="#Onda.TimeSpan"><code>TimeSpan</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/timespans.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.TimeSpan" href="#Onda.TimeSpan"><code>Onda.TimeSpan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TimeSpan(first, last)</code></pre><p>Return <code>TimeSpan(Nanosecond(first), Nanosecond(last))::AbstractTimeSpan</code>.</p><p>If <code>first == last</code>, a single <code>Nanosecond</code> is added to <code>last</code> since <code>last</code> is an exclusive upper bound and Onda only supports up to nanosecond precision anyway. This behavior also avoids most practical forms of potential breakage w.r.t to legacy versions of Onda that accidentally allowed the construction of <code>TimeSpans</code> where <code>first == last</code>.</p><p>See also: <a href="#Onda.AbstractTimeSpan"><code>AbstractTimeSpan</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/timespans.jl#L31-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.contains" href="#Onda.contains"><code>Onda.contains</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">contains(a::AbstractTimeSpan, b::AbstractTimeSpan)</code></pre><p>Return <code>true</code> if the timespan <code>b</code> lies entirely within the timespan <code>a</code>, return <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/timespans.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.overlaps" href="#Onda.overlaps"><code>Onda.overlaps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">overlaps(a, b)</code></pre><p>Return <code>true</code> if the timespan <code>a</code> and the timespan <code>b</code> overlap, return <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/timespans.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.shortest_timespan_containing" href="#Onda.shortest_timespan_containing"><code>Onda.shortest_timespan_containing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">shortest_timespan_containing(spans)</code></pre><p>Return the shortest possible <code>TimeSpan</code> containing all timespans in <code>spans</code>.</p><p><code>spans</code> is assumed to be an iterable of timespans.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/timespans.jl#L100-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.duration" href="#Onda.duration"><code>Onda.duration</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">duration(span)</code></pre><p>Return the duration of <code>span</code> as a <code>Period</code>.</p><p>For <code>span::AbstractTimeSpan</code>, this is equivalent to <code>last(span) - first(span)</code>.</p><p>For <code>span::Period</code>, this function is the identity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/timespans.jl#L117-L125">source</a></section><section><div><pre><code class="language-none">duration(signal::Signal)</code></pre><p>Return <code>duration(span(signal))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/recordings.jl#L236-L240">source</a></section><section><div><pre><code class="language-none">duration(recording::Recording)</code></pre><p>Returns <code>maximum(s -&gt; s.stop_nanosecond, values(recording.signals))</code>; throws an <code>ArgumentError</code> if <code>recording.signals</code> is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/recordings.jl#L292-L297">source</a></section><section><div><pre><code class="language-none">duration(samples::Samples)</code></pre><p>Returns the <code>Nanosecond</code> value for which <code>samples[TimeSpan(0, duration(samples))] == samples.data</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>duration(samples)</code> is not generally equivalent to <code>duration(samples.signal)</code>; the former is the duration of the entire original signal in the context of its parent recording, whereas the latter is the actual duration of <code>samples.data</code> given <code>samples.signal.sample_rate</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/samples.jl#L119-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.time_from_index" href="#Onda.time_from_index"><code>Onda.time_from_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">time_from_index(sample_rate, sample_index)</code></pre><p>Given <code>sample_rate</code> in Hz and assuming <code>sample_index &gt; 0</code>, return the earliest <code>Nanosecond</code> containing <code>sample_index</code>.</p><p>Examples:</p><pre><code class="language-none">julia&gt; time_from_index(1, 1)
0 nanoseconds

julia&gt; time_from_index(1, 2)
1000000000 nanoseconds

julia&gt; time_from_index(100, 100)
990000000 nanoseconds

julia&gt; time_from_index(100, 101)
1000000000 nanoseconds</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/timespans.jl#L184-L205">source</a></section><section><div><pre><code class="language-none">time_from_index(sample_rate, sample_range::AbstractUnitRange)</code></pre><p>Return the <code>TimeSpan</code> corresponding to <code>sample_range</code> given <code>sample_rate</code> in Hz:</p><pre><code class="language-none">julia&gt; time_from_index(100, 1:100)
TimeSpan(0 nanoseconds, 1000000000 nanoseconds)

julia&gt; time_from_index(100, 101:101)
TimeSpan(1000000000 nanoseconds, 1000000001 nanoseconds)

julia&gt; time_from_index(100, 301:600)
TimeSpan(3000000000 nanoseconds, 6000000000 nanoseconds)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/timespans.jl#L211-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.index_from_time" href="#Onda.index_from_time"><code>Onda.index_from_time</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">index_from_time(sample_rate, sample_time)</code></pre><p>Given <code>sample_rate</code> in Hz, return the integer index of the most recent sample taken at <code>sample_time</code>. Note that <code>sample_time</code> must be non-negative and support <code>convert(Nanosecond, sample_time)</code>.</p><p>Examples:</p><pre><code class="language-none">julia&gt; index_from_time(1, Second(0))
1

julia&gt; index_from_time(1, Second(1))
2

julia&gt; index_from_time(100, Millisecond(999))
100

julia&gt; index_from_time(100, Millisecond(1000))
101</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/timespans.jl#L131-L153">source</a></section><section><div><pre><code class="language-none">index_from_time(sample_rate, span::AbstractTimeSpan)</code></pre><p>Return the <code>UnitRange</code> of indices corresponding to <code>span</code> given <code>sample_rate</code> in Hz:</p><pre><code class="language-none">julia&gt; index_from_time(100, TimeSpan(Second(0), Second(1)))
1:100

julia&gt; index_from_time(100, TimeSpan(Second(1)))
101:101

julia&gt; index_from_time(100, TimeSpan(Second(3), Second(6)))
301:600</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/timespans.jl#L161-L176">source</a></section></article><h2 id="Paths-API-1"><a class="docs-heading-anchor" href="#Paths-API-1">Paths API</a><a class="docs-heading-anchor-permalink" href="#Paths-API-1" title="Permalink"></a></h2><p>Onda&#39;s Paths API directly underlies its Dataset API, providing an abstraction layer that can be overloaded to support new storage backends for sample data and recording metadata. This API&#39;s fallback implementation supports any path-like type <code>P</code> that supports:</p><ul><li><code>Base.read(::P)</code></li><li><code>Base.write(::P, bytes::Vector{UInt8})</code></li><li><code>Base.rm(::P; force, recursive)</code></li><li><code>Base.joinpath(::P, ::AbstractString...)</code></li><li><code>Base.mkpath(::P)</code> (note: this is allowed to be a no-op for storage backends which have no notion of intermediate directories, e.g. object storage systems)</li><li><code>Base.dirname(::P)</code></li><li><code>Onda.read_byte_range</code> (see signatures documented below)</li></ul><article class="docstring"><header><a class="docstring-binding" id="Onda.read_recordings_file" href="#Onda.read_recordings_file"><code>Onda.read_recordings_file</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_recordings_file(path)</code></pre><p>Return <code>deserialize_recordings_msgpack_zst(read(path))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/paths.jl#L37-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.write_recordings_file" href="#Onda.write_recordings_file"><code>Onda.write_recordings_file</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">write_recordings_file(path, header::Header, recordings::Dict{UUID,Recording})</code></pre><p>Write <code>serialize_recordings_msgpack_zst(header, recordings)</code> to <code>path</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/paths.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.samples_path" href="#Onda.samples_path"><code>Onda.samples_path</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">samples_path(dataset_path, uuid::UUID)</code></pre><p>Return the path to the samples subdirectory within <code>dataset_path</code> corresponding to the recording specified by <code>uuid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/paths.jl#L48-L53">source</a></section><section><div><pre><code class="language-none">samples_path(dataset_path, uuid::UUID, signal_name, file_extension)</code></pre><p>Return the path to the sample data within <code>dataset_path</code> corresponding to the given signal information and the recording specified by <code>uuid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/paths.jl#L56-L61">source</a></section><section><div><pre><code class="language-none">samples_path(dataset::Dataset, uuid::UUID)</code></pre><p>Return <code>samples_path(dataset.path, uuid)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/dataset.jl#L121-L125">source</a></section><section><div><pre><code class="language-none">samples_path(dataset::Dataset, uuid::UUID, signal_name::Symbol)</code></pre><p>Return <code>samples_path(dataset.path, uuid, signal_name, extension)</code> where <code>extension</code> is defined as <code>dataset.recordings[uuid].signals[signal_name].file_extension</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/dataset.jl#L128-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.read_samples" href="#Onda.read_samples"><code>Onda.read_samples</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_samples(path, signal::Signal)</code></pre><p>Return the <code>Samples</code> object described by <code>signal</code> and stored at <code>path</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/paths.jl#L71-L75">source</a></section><section><div><pre><code class="language-none">read_samples(path, signal::Signal, span::AbstractTimeSpan)</code></pre><p>Return <code>read_samples(path, signal)[:, span]</code>, but attempt to avoid reading unreturned intermediate sample data. Note that the effectiveness of this method depends on the types of both <code>path</code> and <code>format(signal)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/paths.jl#L80-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.write_samples" href="#Onda.write_samples"><code>Onda.write_samples</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">write_samples(path, samples::Samples)</code></pre><p>Serialize and write <code>encode(samples)</code> to <code>path</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/paths.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.read_byte_range" href="#Onda.read_byte_range"><code>Onda.read_byte_range</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_byte_range(path, byte_offset, byte_count)</code></pre><p>Return the equivalent <code>read(path)[(byte_offset + 1):(byte_offset + byte_count)]</code>, but try to avoid reading unreturned intermediate bytes. Note that the effectiveness of this method depends on the type of <code>path</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/paths.jl#L7-L13">source</a></section></article><h2 id="Serialization-API-1"><a class="docs-heading-anchor" href="#Serialization-API-1">Serialization API</a><a class="docs-heading-anchor-permalink" href="#Serialization-API-1" title="Permalink"></a></h2><p>Onda&#39;s Serialization API underlies its Paths API, providing a storage-agnostic abstraction layer that can be overloaded to support new file/byte formats for (de)serializing LPCM-encodeable sample data. This API also facilitates low-level streaming sample data (de)serialization and Onda metadata (de)serialization.</p><article class="docstring"><header><a class="docstring-binding" id="Onda.deserialize_recordings_msgpack_zst" href="#Onda.deserialize_recordings_msgpack_zst"><code>Onda.deserialize_recordings_msgpack_zst</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">deserialize_recordings_msgpack_zst(bytes::Vector{UInt8})</code></pre><p>Return the <code>(header::Header, recordings::Dict{UUID,Recording})</code> yielded from deserializing <code>bytes</code>, which is assumed to be in zstd-compressed MsgPack format and comply with the Onda format&#39;s specification of the contents of <code>recordings.msgpack.zst</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/serialization.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.serialize_recordings_msgpack_zst" href="#Onda.serialize_recordings_msgpack_zst"><code>Onda.serialize_recordings_msgpack_zst</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">serialize_recordings_msgpack_zst(header::Header, recordings::Dict{UUID,Recording})</code></pre><p>Return the <code>Vector{UInt8}</code> that results from serializing <code>(header::Header, recordings::Dict{UUID,Recording})</code> to zstd-compressed MsgPack format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/serialization.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.AbstractLPCMFormat" href="#Onda.AbstractLPCMFormat"><code>Onda.AbstractLPCMFormat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractLPCMFormat</code></pre><p>A type whose subtypes represents byte/stream formats that can be (de)serialized to/from Onda&#39;s standard interleaved LPCM representation.</p><p>All subtypes of the form <code>F&lt;:AbstractLPCMFormat</code> must support a constructor of the form <code>F(::Signal)</code> and overload <code>Onda.format_constructor_for_file_extension</code> with the appropriate file extension.</p><p>See also:</p><ul><li><a href="#Onda.format"><code>format</code></a></li><li><a href="#Onda.deserialize_lpcm"><code>deserialize_lpcm</code></a></li><li><a href="#Onda.deserialize_lpcm_callback"><code>deserialize_lpcm_callback</code></a></li><li><a href="#Onda.serialize_lpcm"><code>serialize_lpcm</code></a></li><li><a href="#Onda.LPCM"><code>LPCM</code></a></li><li><a href="#Onda.LPCMZst"><code>LPCMZst</code></a></li><li><a href="#Onda.AbstractLPCMStream"><code>AbstractLPCMStream</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/serialization.jl#L52-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.AbstractLPCMStream" href="#Onda.AbstractLPCMStream"><code>Onda.AbstractLPCMStream</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractLPCMStream</code></pre><p>A type that represents an LPCM (de)serialization stream.</p><p>See also:</p><ul><li><a href="#Onda.deserializing_lpcm_stream"><code>deserializing_lpcm_stream</code></a></li><li><a href="#Onda.serializing_lpcm_stream"><code>serializing_lpcm_stream</code></a></li><li><a href="#Onda.finalize_lpcm_stream"><code>finalize_lpcm_stream</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/serialization.jl#L74-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.deserializing_lpcm_stream" href="#Onda.deserializing_lpcm_stream"><code>Onda.deserializing_lpcm_stream</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">deserializing_lpcm_stream(format::AbstractLPCMFormat, io)</code></pre><p>Return a <code>stream::AbstractLPCMStream</code> that wraps <code>io</code> to enable direct LPCM deserialization from <code>io</code> via <a href="#Onda.deserialize_lpcm"><code>deserialize_lpcm</code></a>.</p><p>Note that <code>stream</code> must be finalized after usage via <a href="#Onda.finalize_lpcm_stream"><code>finalize_lpcm_stream</code></a>. Until <code>stream</code> is finalized, <code>io</code> should be considered to be part of the internal state of <code>stream</code> and should not be directly interacted with by other processes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/serialization.jl#L133-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.serializing_lpcm_stream" href="#Onda.serializing_lpcm_stream"><code>Onda.serializing_lpcm_stream</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">serializing_lpcm_stream(format::AbstractLPCMFormat, io)</code></pre><p>Return a <code>stream::AbstractLPCMStream</code> that wraps <code>io</code> to enable direct LPCM serialization to <code>io</code> via <a href="#Onda.serialize_lpcm"><code>serialize_lpcm</code></a>.</p><p>Note that <code>stream</code> must be finalized after usage via <a href="#Onda.finalize_lpcm_stream"><code>finalize_lpcm_stream</code></a>. Until <code>stream</code> is finalized, <code>io</code> should be considered to be part of the internal state of <code>stream</code> and should not be directly interacted with by other processes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/serialization.jl#L145-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.finalize_lpcm_stream" href="#Onda.finalize_lpcm_stream"><code>Onda.finalize_lpcm_stream</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">finalize_lpcm_stream(stream::AbstractLPCMStream)::Bool</code></pre><p>Finalize <code>stream</code>, returning <code>true</code> if the underlying I/O object used to construct <code>stream</code> is still open and usable. Otherwise, return <code>false</code> to indicate that underlying I/O object was closed as result of finalization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/serialization.jl#L157-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.format_constructor_for_file_extension" href="#Onda.format_constructor_for_file_extension"><code>Onda.format_constructor_for_file_extension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Onda.format_constructor_for_file_extension(::Val{:extension_symbol})</code></pre><p>Return a constructor of the form <code>F(::Signal)::AbstractLPCMFormat</code> corresponding to the provided extension.</p><p>This function should be overloaded for new <code>AbstractLPCMFormat</code> subtypes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/serialization.jl#L87-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.format" href="#Onda.format"><code>Onda.format</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">format(signal::Signal; kwargs...)</code></pre><p>Return <code>F(signal; kwargs...)</code> where <code>F</code> is the <code>AbstractLPCMFormat</code> that corresponds to <code>signal.file_extension</code> (as determined by the format author via <code>format_constructor_for_file_extension</code>).</p><p>See also: <a href="#Onda.deserialize_lpcm"><code>deserialize_lpcm</code></a>, <a href="#Onda.serialize_lpcm"><code>serialize_lpcm</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/serialization.jl#L99-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.deserialize_lpcm" href="#Onda.deserialize_lpcm"><code>Onda.deserialize_lpcm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">deserialize_lpcm(format::AbstractLPCMFormat, bytes,
                 samples_offset::Integer=0,
                 samples_count::Integer=typemax(Int))
deserialize_lpcm(stream::AbstractLPCMStream,
                 samples_offset::Integer=0,
                 samples_count::Integer=typemax(Int))</code></pre><p>Return a channels-by-timesteps <code>AbstractMatrix</code> of interleaved LPCM-encoded sample data by deserializing the provided <code>bytes</code> in the given <code>format</code>, or from the given <code>stream</code> constructed by <a href="#Onda.deserializing_lpcm_stream"><code>deserializing_lpcm_stream</code></a>.</p><p>Note that this operation may be performed in a zero-copy manner such that the returned sample matrix directly aliases <code>bytes</code>.</p><p>The returned segment is at most <code>sample_offset</code> samples offset from the start of <code>stream</code>/<code>bytes</code> and contains at most <code>sample_count</code> samples. This ensures that overrun behavior is generally similar to the behavior of <code>Base.skip(io, n)</code> and <code>Base.read(io, n)</code>.</p><p>This function is the inverse of the corresponding <a href="#Onda.serialize_lpcm"><code>serialize_lpcm</code></a> method, i.e.:</p><pre><code class="language-none">serialize_lpcm(format, deserialize_lpcm(format, bytes)) == bytes</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/serialization.jl#L166-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.deserialize_lpcm_callback" href="#Onda.deserialize_lpcm_callback"><code>Onda.deserialize_lpcm_callback</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">deserialize_lpcm_callback(format::AbstractLPCMFormat, samples_offset, samples_count)</code></pre><p>Return <code>(callback, required_byte_offset, required_byte_count)</code> where <code>callback</code> accepts the byte block specified by <code>required_byte_offset</code> and <code>required_byte_count</code> and returns the samples specified by <code>samples_offset</code> and <code>samples_count</code>.</p><p>As a fallback, this function returns <code>(callback, missing, missing)</code>, where <code>callback</code> requires all available bytes. <code>AbstractLPCMFormat</code> subtypes that support partial/block-based deserialization (e.g. the basic <code>LPCM</code> format) can overload this function to only request exactly the byte range that is required for the sample range requested by the caller.</p><p>This allows callers to handle the byte block retrieval themselves while keeping Onda&#39;s LPCM Serialization API agnostic to the caller&#39;s storage layer of choice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/serialization.jl#L113-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.serialize_lpcm" href="#Onda.serialize_lpcm"><code>Onda.serialize_lpcm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">serialize_lpcm(format::AbstractLPCMFormat, samples::AbstractMatrix)
serialize_lpcm(stream::AbstractLPCMStream, samples::AbstractMatrix)</code></pre><p>Return the <code>AbstractVector{UInt8}</code> of bytes that results from serializing <code>samples</code> to the given <code>format</code> (or serialize those bytes directly to <code>stream</code>) where <code>samples</code> is a channels-by-timesteps matrix of interleaved LPCM-encoded sample data.</p><p>Note that this operation may be performed in a zero-copy manner such that the returned <code>AbstractVector{UInt8}</code> directly aliases <code>samples</code>.</p><p>This function is the inverse of the corresponding <a href="#Onda.deserialize_lpcm"><code>deserialize_lpcm</code></a> method, i.e.:</p><pre><code class="language-none">deserialize_lpcm(format, serialize_lpcm(format, samples)) == samples</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/serialization.jl#L194-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.LPCM" href="#Onda.LPCM"><code>Onda.LPCM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LPCM{S}(channel_count)
LPCM(signal::Signal)</code></pre><p>Return a <code>LPCM&lt;:AbstractLPCMFormat</code> instance corresponding to Onda&#39;s default interleaved LPCM format assumed for sample data files with the &quot;lpcm&quot; extension.</p><p><code>S</code> corresponds to <code>signal.sample_type</code>, while <code>channel_count</code> corresponds to <code>length(signal.channel_names)</code>.</p><p>Note that bytes (de)serialized to/from this format are little-endian (per the Onda specification).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/serialization.jl#L220-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.LPCMZst" href="#Onda.LPCMZst"><code>Onda.LPCMZst</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LPCMZst(lpcm::LPCM; level=3)
LPCMZst(signal::Signal; level=3)</code></pre><p>Return a <code>LPCMZst&lt;:AbstractLPCMFormat</code> instance that corresponds to Onda&#39;s default interleaved LPCM format compressed by <code>zstd</code>. This format is assumed for sample data files with the &quot;lpcm.zst&quot; extension.</p><p>The <code>level</code> keyword argument sets the same compression level parameter as the corresponding flag documented by the <code>zstd</code> command line utility.</p><p>See https://facebook.github.io/zstd/ for details about <code>zstd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/serialization.jl#L314-L326">source</a></section></article><h2 id="Upgrading-Older-Datasets-to-Newer-Datasets-1"><a class="docs-heading-anchor" href="#Upgrading-Older-Datasets-to-Newer-Datasets-1">Upgrading Older Datasets to Newer Datasets</a><a class="docs-heading-anchor-permalink" href="#Upgrading-Older-Datasets-to-Newer-Datasets-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Onda.upgrade_onda_format_from_v0_2_to_v0_3!" href="#Onda.upgrade_onda_format_from_v0_2_to_v0_3!"><code>Onda.upgrade_onda_format_from_v0_2_to_v0_3!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Onda.upgrade_onda_format_from_v0_2_to_v0_3!(path, combine_annotation_key_value)</code></pre><p>Upgrade the Onda v0.2 dataset at <code>path</code> to a Onda v0.3 dataset, returning the upgraded <code>Dataset</code>. This upgrade process overwrites <code>path/recordings.msgpack.zst</code> with a v0.3-compliant version of this file; for safety&#39;s sake, the old v0.2 file is preserved at <code>path/old.recordings.msgpack.zst.backup</code>.</p><p>A couple of the Onda v0.2 -&gt; v0.3 changes require some special handling:</p><ul><li><p>The <code>custom</code> field was removed from recording objects. This function thus writes out a file at <code>path/recordings_custom.msgpack.zst</code> that contains a map of UUIDs to corresponding recordings&#39; <code>custom</code> values before deleting the <code>custom</code> field. This file can be deserialized via <code>MsgPack.unpack(Onda.zstd_decompress(read(&quot;recordings_custom.msgpack.zst&quot;)))</code>.</p></li><li><p>Annotations no longer have a <code>key</code> field. Thus, each annotation&#39;s existing <code>key</code> and <code>value</code> fields are combined into the single new <code>value</code> field via the provided callback <code>combine_annotation_key_value(annotation_key, annotation_value)</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/ff427d9c777036d2a30f6758ea01c861bd1b7dce/src/Onda.jl#L105-L123">source</a></section></article></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 18 October 2020 14:11">Sunday 18 October 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
