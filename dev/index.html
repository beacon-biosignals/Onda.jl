<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Documentation · Onda</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Onda</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>API Documentation</a><ul class="internal"><li><a class="tocitem" href="#Support-For-Generic-Path-Like-Types-1"><span>Support For Generic Path-Like Types</span></a></li><li><a class="tocitem" href="#onda.annotation-1"><span><code>onda.annotation</code></span></a></li><li><a class="tocitem" href="#onda.signal-1"><span><code>onda.signal</code></span></a></li><li><a class="tocitem" href="#Samples-1"><span><code>Samples</code></span></a></li><li><a class="tocitem" href="#LPCM-(De)serialization-API-1"><span>LPCM (De)serialization API</span></a></li><li><a class="tocitem" href="#Utilities-1"><span>Utilities</span></a></li><li><a class="tocitem" href="#Developer-Installation-1"><span>Developer Installation</span></a></li></ul></li><li><a class="tocitem" href="upgrading/">Upgrading From Older Versions Of Onda</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/beacon-biosignals/Onda.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Documentation-1"><a class="docs-heading-anchor" href="#API-Documentation-1">API Documentation</a><a class="docs-heading-anchor-permalink" href="#API-Documentation-1" title="Permalink"></a></h1><p>We highly recommend that newcomers walk through the <a href="https://github.com/beacon-biosignals/Onda.jl/blob/master/examples/tour.jl">Onda Tour</a> before diving into this reference documentation.</p><h2 id="Support-For-Generic-Path-Like-Types-1"><a class="docs-heading-anchor" href="#Support-For-Generic-Path-Like-Types-1">Support For Generic Path-Like Types</a><a class="docs-heading-anchor-permalink" href="#Support-For-Generic-Path-Like-Types-1" title="Permalink"></a></h2><p>Onda.jl attempts to be as agnostic as possible with respect to the storage system that sample data, Arrow files, etc. are read from/written to. As such, any path-like argument accepted by an Onda.jl API function should generically &quot;work&quot; as long as the argument&#39;s type supports:</p><ul><li><code>Base.read(path)::Vector{UInt8}</code> (return the bytes stored at <code>path</code>)</li><li><code>Base.write(path, bytes::Vector{UInt8})</code> (write <code>bytes</code> to the location specified by <code>path</code>)</li></ul><p>For backends which support direct byte range access (e.g. S3), <code>Onda.read_byte_range</code> may be overloaded for the backend&#39;s corresponding path type to enable further optimizations:</p><article class="docstring"><header><a class="docstring-binding" id="Onda.read_byte_range" href="#Onda.read_byte_range"><code>Onda.read_byte_range</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_byte_range(path, byte_offset, byte_count)</code></pre><p>Return the equivalent <code>read(path)[(byte_offset + 1):(byte_offset + byte_count)]</code>, but try to avoid reading unreturned intermediate bytes. Note that the effectiveness of this method depends on the type of <code>path</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/utilities.jl#L56-L62">source</a></section></article><h2 id="onda.annotation-1"><a class="docs-heading-anchor" href="#onda.annotation-1"><code>onda.annotation</code></a><a class="docs-heading-anchor-permalink" href="#onda.annotation-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Onda.Annotation" href="#Onda.Annotation"><code>Onda.Annotation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const Annotation = Legolas.@row(&quot;onda.annotation@1&quot;,
                                recording::UUID,
                                id::UUID,
                                span::TimeSpan)</code></pre><p>A type alias for <a href="https://beacon-biosignals.github.io/Legolas.jl/stable/#Legolas.@row"><code>Legolas.Row{typeof(Legolas.Schema(&quot;onda.annotation@1&quot;))}</code></a> representing an <a href="https://github.com/beacon-biosignals/Onda.jl##ondaannotation1"><code>onda.annotation</code> as described by the Onda Format Specification</a>.</p><p>This type primarily exists to aid in the validated row construction, and is not intended to be used as a type constraint in function or struct definitions. Instead, you should generally duck-type any &quot;annotation-like&quot; arguments/fields so that other generic row types will compose with your code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/annotations.jl#L8-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.write_annotations" href="#Onda.write_annotations"><code>Onda.write_annotations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">write_annotations(io_or_path, table; kwargs...)</code></pre><p>Invoke/return <code>Legolas.write(path_or_io, annotations, Schema(&quot;onda.annotation@1&quot;); kwargs...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/annotations.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.merge_overlapping_annotations" href="#Onda.merge_overlapping_annotations"><code>Onda.merge_overlapping_annotations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">merge_overlapping_annotations(annotations)</code></pre><p>Given the <code>onda.annotation</code>-compliant table <code>annotations</code>, return a table corresponding to <code>annotations</code> except that overlapping entries have been merged.</p><p>Specifically, two annotations <code>a</code> and <code>b</code> are determined to be &quot;overlapping&quot; if <code>a.recording == b.recording &amp;&amp; TimeSpans.overlaps(a.span, b.span)</code>. Merged annotations&#39; <code>span</code> fields are generated via calling <code>TimeSpans.shortest_timespan_containing</code> on the overlapping set of source annotations.</p><p>The returned annotations table only has a single custom column named <code>from</code> whose entries are <code>Vector{UUID}</code>s populated with the <code>id</code>s of the generated annotations&#39; source(s). Note that every annotation in the returned table has a freshly generated <code>id</code> field and a non-empty <code>from</code> field, even if the <code>from</code> only has a single element (i.e. corresponds to a single non-overlapping annotation).</p><p>Note that this function internally works with <code>Tables.columns(annotations)</code> rather than <code>annotations</code> directly, so it may be slower and/or require more memory if <code>!Tables.columnaccess(annotations)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/annotations.jl#L37-L59">source</a></section></article><h2 id="onda.signal-1"><a class="docs-heading-anchor" href="#onda.signal-1"><code>onda.signal</code></a><a class="docs-heading-anchor-permalink" href="#onda.signal-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Onda.Signal" href="#Onda.Signal"><code>Onda.Signal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const Signal = @row(&quot;onda.signal@1&quot; &gt; &quot;onda.samples-info@1&quot;,
                    recording::UUID,
                    file_path::Any,
                    file_format::String = (file_format isa AbstractLPCMFormat ?
                                           Onda.file_format_string(file_format) :
                                           file_format),
                    span::TimeSpan,
                    kind::String,
                    channels::Vector{String},
                    sample_unit::String)</code></pre><p>A type alias for <a href="https://beacon-biosignals.github.io/Legolas.jl/stable/#Legolas.@row"><code>Legolas.Row{typeof(Legolas.Schema(&quot;onda.signal@1&quot;))}</code></a> representing an <a href="https://github.com/beacon-biosignals/Onda.jl##ondasignal1"><code>onda.signal</code> as described by the Onda Format Specification</a>.</p><p>This type primarily exists to aid in the validated row construction, and is not intended to be used as a type constraint in function or struct definitions. Instead, you should generally duck-type any &quot;signal-like&quot; arguments/fields so that other generic row types will compose with your code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/signals.jl#L78-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.SamplesInfo" href="#Onda.SamplesInfo"><code>Onda.SamplesInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const SamplesInfo = @row(&quot;onda.samples-info@1&quot;,
                         kind::String,
                         channels::Vector{String},
                         sample_unit::String,
                         sample_resolution_in_unit::LPCM_SAMPLE_TYPE_UNION,
                         sample_offset_in_unit::LPCM_SAMPLE_TYPE_UNION,
                         sample_type::String = Onda.onda_sample_type_from_julia_type(sample_type),
                         sample_rate::LPCM_SAMPLE_TYPE_UNION)</code></pre><p>A type alias for <a href="https://beacon-biosignals.github.io/Legolas.jl/stable/#Legolas.@row"><code>Legolas.Row{typeof(Legolas.Schema(&quot;onda.samples-info@1&quot;))}</code></a> representing the bundle of <code>onda.signal</code> fields that are intrinsic to a signal&#39;s sample data, leaving out extrinsic file or recording information. This is useful when the latter information is irrelevant or does not yet exist (e.g. if sample data is being constructed/manipulated in-memory without yet having been serialized).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/signals.jl#L46-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.write_signals" href="#Onda.write_signals"><code>Onda.write_signals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">write_signals(io_or_path, table; kwargs...)</code></pre><p>Invoke/return <code>Legolas.write(path_or_io, signals, Schema(&quot;onda.signal@1&quot;); kwargs...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/signals.jl#L125-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel-Tuple{Any, Any}" href="#Onda.channel-Tuple{Any, Any}"><code>Onda.channel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">channel(x, name)</code></pre><p>Return <code>i</code> where <code>x.channels[i] == name</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/signals.jl#L136-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel-Tuple{Any, Integer}" href="#Onda.channel-Tuple{Any, Integer}"><code>Onda.channel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">channel(x, i::Integer)</code></pre><p>Return <code>x.channels[i]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/signals.jl#L143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel_count-Tuple{Any}" href="#Onda.channel_count-Tuple{Any}"><code>Onda.channel_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">channel_count(x)</code></pre><p>Return <code>length(x.channels)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/signals.jl#L150-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.sample_count-Tuple{Any, Dates.Period}" href="#Onda.sample_count-Tuple{Any, Dates.Period}"><code>Onda.sample_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sample_count(x, duration::Period)</code></pre><p>Return the number of multichannel samples that fit within <code>duration</code> given <code>x.sample_rate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/signals.jl#L157-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.sizeof_samples-Tuple{Any, Dates.Period}" href="#Onda.sizeof_samples-Tuple{Any, Dates.Period}"><code>Onda.sizeof_samples</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sizeof_samples(x, duration::Period)</code></pre><p>Returns the expected size (in bytes) of an encoded <code>Samples</code> object corresponding to <code>x</code> and <code>duration</code>:</p><pre><code class="language-none">sample_count(x, duration) * channel_count(x) * sizeof(x.sample_type)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/signals.jl#L171-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.sample_type-Tuple{Any}" href="#Onda.sample_type-Tuple{Any}"><code>Onda.sample_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sample_type(x)</code></pre><p>Return <code>x.sample_type</code> as an <code>Onda.LPCM_SAMPLE_TYPE_UNION</code> subtype. If <code>x.sample_type</code> is an Onda-specified <code>sample_type</code> string (e.g. <code>&quot;int16&quot;</code>), it will be converted to the corresponding Julia type. If <code>x.sample_type &lt;: Onda.LPCM_SAMPLE_TYPE_UNION</code>, this function simply returns <code>x.sample_type</code> as-is.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/signals.jl#L164-L168">source</a></section></article><h2 id="Samples-1"><a class="docs-heading-anchor" href="#Samples-1"><code>Samples</code></a><a class="docs-heading-anchor-permalink" href="#Samples-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Onda.Samples" href="#Onda.Samples"><code>Onda.Samples</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Samples(data::AbstractMatrix, info::SamplesInfo, encoded::Bool;
        validate::Bool=Onda.VALIDATE_SAMPLES_DEFAULT[])</code></pre><p>Return a <code>Samples</code> instance with the following fields:</p><ul><li><p><code>data::AbstractMatrix</code>: A matrix of sample data. The <code>i</code> th row of the matrix corresponds to the <code>i</code>th channel in <code>info.channels</code>, while the <code>j</code>th column corresponds to the <code>j</code>th multichannel sample.</p></li><li><p><code>info::SamplesInfo</code>: The <code>SamplesInfo</code> object that describes the <code>Samples</code> instance.</p></li><li><p><code>encoded::Bool</code>: If <code>true</code>, the values in <code>data</code> are LPCM-encoded as prescribed by the <code>Samples</code> instance&#39;s <code>info</code>. If <code>false</code>, the values in <code>data</code> have been decoded into the <code>info</code>&#39;s canonical units.</p></li></ul><p>If <code>validate</code> is <code>true</code>, <a href="@ref"><code>Onda.validate</code></a> is called on the constructed <code>Samples</code> instance before it is returned.</p><p>Note that <code>getindex</code> and <code>view</code> are defined on <code>Samples</code> to accept normal integer indices, but also accept channel names or a regex to match channel names for row indices, and <code>TimeSpan</code> values for column indices; see <code>Onda/examples/tour.jl</code> for a comprehensive set of indexing examples.</p><p>See also: <a href="#Onda.load"><code>load</code></a>, <a href="#Onda.store"><code>store</code></a>, <a href="#Onda.encode"><code>encode</code></a>, <a href="#Onda.encode!"><code>encode!</code></a>, <a href="#Onda.decode"><code>decode</code></a>, <a href="#Onda.decode!"><code>decode!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/samples.jl#L21-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{Samples, Samples}" href="#Base.:==-Tuple{Samples, Samples}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">==(a::Samples, b::Samples)</code></pre><p>Returns <code>a.encoded == b.encoded &amp;&amp; a.info == b.info &amp;&amp; a.data == b.data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/samples.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel" href="#Onda.channel"><code>Onda.channel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">channel(x, name)</code></pre><p>Return <code>i</code> where <code>x.channels[i] == name</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/signals.jl#L136-L140">source</a></section><section><div><pre><code class="language-julia">channel(x, i::Integer)</code></pre><p>Return <code>x.channels[i]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/signals.jl#L143-L147">source</a></section><section><div><pre><code class="language-julia">channel(samples::Samples, name)</code></pre><p>Return <code>channel(samples.info, name)</code>.</p><p>This function is useful for indexing rows of <code>samples.data</code> by channel names.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/samples.jl#L96-L102">source</a></section><section><div><pre><code class="language-julia">channel(samples::Samples, i::Integer)</code></pre><p>Return <code>channel(samples.info, i)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/samples.jl#L105-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel_count" href="#Onda.channel_count"><code>Onda.channel_count</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">channel_count(x)</code></pre><p>Return <code>length(x.channels)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/signals.jl#L150-L154">source</a></section><section><div><pre><code class="language-julia">channel_count(samples::Samples)</code></pre><p>Return <code>channel_count(samples.info)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/samples.jl#L112-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.sample_count" href="#Onda.sample_count"><code>Onda.sample_count</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sample_count(x, duration::Period)</code></pre><p>Return the number of multichannel samples that fit within <code>duration</code> given <code>x.sample_rate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/signals.jl#L157-L161">source</a></section><section><div><pre><code class="language-julia">sample_count(samples::Samples)</code></pre><p>Return the number of multichannel samples in <code>samples</code> (i.e. <code>size(samples.data, 2)</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/samples.jl#L119-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.encode" href="#Onda.encode"><code>Onda.encode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">encode(sample_type::DataType, sample_resolution_in_unit, sample_offset_in_unit,
       sample_data, dither_storage=nothing)</code></pre><p>Return a copy of <code>sample_data</code> quantized according to <code>sample_type</code>, <code>sample_resolution_in_unit</code>, and <code>sample_offset_in_unit</code>. <code>sample_type</code> must be a concrete subtype of <code>Onda.VALID_SAMPLE_TYPE_UNION</code>. Quantization of an individual sample <code>s</code> is performed via:</p><pre><code class="language-none">round(S, (s - sample_offset_in_unit) / sample_resolution_in_unit)</code></pre><p>with additional special casing to clip values exceeding the encoding&#39;s dynamic range.</p><p>If <code>dither_storage isa Nothing</code>, no dithering is applied before quantization.</p><p>If <code>dither_storage isa Missing</code>, dither storage is allocated automatically and triangular dithering is applied to the info prior to quantization.</p><p>Otherwise, <code>dither_storage</code> must be a container of similar shape and type to <code>sample_data</code>. This container is then used to store the random noise needed for the triangular dithering process, which is applied to the info prior to quantization.</p><p>If:</p><pre><code class="language-none">sample_type === eltype(sample_data) &amp;&amp;
sample_resolution_in_unit == 1 &amp;&amp;
sample_offset_in_unit == 0</code></pre><p>then this function will simply return <code>sample_data</code> directly without copying/dithering.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/samples.jl#L194-L222">source</a></section><section><div><pre><code class="language-none">encode(samples::Samples, dither_storage=nothing)</code></pre><p>If <code>samples.encoded</code> is <code>false</code>, return a <code>Samples</code> instance that wraps:</p><pre><code class="language-none">encode(sample_type(samples.info),
       samples.info.sample_resolution_in_unit,
       samples.info.sample_offset_in_unit,
       samples.data, dither_storage)</code></pre><p>If <code>samples.encoded</code> is <code>true</code>, this function is the identity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/samples.jl#L286-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.encode!" href="#Onda.encode!"><code>Onda.encode!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">encode!(result_storage, sample_type::DataType, sample_resolution_in_unit,
        sample_offset_in_unit, sample_data, dither_storage=nothing)
encode!(result_storage, sample_resolution_in_unit, sample_offset_in_unit,
        sample_data, dither_storage=nothing)</code></pre><p>Similar to <code>encode(sample_type, sample_resolution_in_unit, sample_offset_in_unit, sample_data, dither_storage)</code>, but write encoded values to <code>result_storage</code> rather than allocating new storage.</p><p><code>sample_type</code> defaults to <code>eltype(result_storage)</code> if it is not provided.</p><p>If:</p><pre><code class="language-none">sample_type === eltype(sample_data) &amp;&amp;
sample_resolution_in_unit == 1 &amp;&amp;
sample_offset_in_unit == 0</code></pre><p>then this function will simply copy <code>sample_data</code> directly into <code>result_storage</code> without dithering.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/samples.jl#L235-L253">source</a></section><section><div><pre><code class="language-none">encode!(result_storage, samples::Samples, dither_storage=nothing)</code></pre><p>If <code>samples.encoded</code> is <code>false</code>, return a <code>Samples</code> instance that wraps:</p><pre><code class="language-none">encode!(result_storage,
        sample_type(samples.info),
        samples.info.sample_resolution_in_unit,
        samples.info.sample_offset_in_unit,
        samples.data, dither_storage)`.</code></pre><p>If <code>samples.encoded</code> is <code>true</code>, return a <code>Samples</code> instance that wraps <code>copyto!(result_storage, samples.data)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/samples.jl#L307-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.decode" href="#Onda.decode"><code>Onda.decode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">decode(sample_resolution_in_unit, sample_offset_in_unit, sample_data)</code></pre><p>Return <code>sample_resolution_in_unit .* sample_data .+ sample_offset_in_unit</code>.</p><p>If:</p><pre><code class="language-none">sample_data isa AbstractArray &amp;&amp;
sample_resolution_in_unit == 1 &amp;&amp;
sample_offset_in_unit == 0</code></pre><p>then this function is the identity and will return <code>sample_data</code> directly without copying.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/samples.jl#L337-L349">source</a></section><section><div><pre><code class="language-none">decode(samples::Samples)</code></pre><p>If <code>samples.encoded</code> is <code>true</code>, return a <code>Samples</code> instance that wraps</p><pre><code class="language-none">decode(samples.info.sample_resolution_in_unit, samples.info.sample_offset_in_unit, samples.data)</code></pre><p>If <code>samples.encoded</code> is <code>false</code>, this function is the identity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/samples.jl#L368-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.decode!" href="#Onda.decode!"><code>Onda.decode!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">decode!(result_storage, sample_resolution_in_unit, sample_offset_in_unit, sample_data)</code></pre><p>Similar to <code>decode(sample_resolution_in_unit, sample_offset_in_unit, sample_data)</code>, but write decoded values to <code>result_storage</code> rather than allocating new storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/samples.jl#L357-L362">source</a></section><section><div><pre><code class="language-none">decode!(result_storage, samples::Samples)</code></pre><p>If <code>samples.encoded</code> is <code>true</code>, return a <code>Samples</code> instance that wraps</p><pre><code class="language-none">decode!(result_storage, samples.info.sample_resolution_in_unit, samples.info.sample_offset_in_unit, samples.data)</code></pre><p>If <code>samples.encoded</code> is <code>false</code>, return a <code>Samples</code> instance that wraps <code>copyto!(result_storage, samples.data)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/samples.jl#L385-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.load" href="#Onda.load"><code>Onda.load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">load(signal[, span]; encoded::Bool=false)
load(file_path, file_format::Union{AbstractString,AbstractLPCMFormat}, info::SamplesInfo[, span]; encoded::Bool=false)</code></pre><p>Return the <code>Samples</code> object described by <code>signal</code>/<code>file_path</code>/<code>file_format</code>/<code>info</code>.</p><p>If <code>span</code> is present, return <code>load(...)[:, span]</code>, but attempt to avoid reading unreturned intermediate sample data. Note that the effectiveness of this optimized method versus the naive approach depends on the types of <code>file_path</code> (i.e. if there is a fast method defined for <code>Onda.read_byte_range(::typeof(file_path), ...)</code>) and <code>file_format</code> (i.e. does the corresponding format support random or chunked access).</p><p>If <code>encoded</code> is <code>true</code>, do not decode the <code>Samples</code> object before returning it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/samples.jl#L408-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.mmap" href="#Onda.mmap"><code>Onda.mmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Onda.mmap(signal)</code></pre><p>Return <code>Onda.mmap(signal.file_path, Onda.extract_samples_info(signal))</code>, throwing an <code>ArgumentError</code> if <code>signal.file_format != &quot;lpcm&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/samples.jl#L443-L447">source</a></section><section><div><pre><code class="language-none">Onda.mmap(mmappable, info::SamplesInfo)</code></pre><p>Return <code>Samples(data, info, true)</code> where <code>data</code> is created via <code>Mmap.mmap(mmappable, ...)</code>.</p><p><code>mmappable</code> is assumed to reference memory that is formatted according to the Onda Format&#39;s canonical interleaved LPCM representation in accordance with <code>sample_type(info)</code> and <code>channel_count(info)</code>. No explicit checks are performed to ensure that this is true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/samples.jl#L453-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.store" href="#Onda.store"><code>Onda.store</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">store(file_path, file_format::Union{AbstractString,AbstractLPCMFormat}, samples::Samples)</code></pre><p>Serialize the given <code>samples</code> to <code>file_format</code> and write the output to <code>file_path</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/samples.jl#L467-L471">source</a></section><section><div><pre><code class="language-none">store(file_path, file_format::Union{AbstractString,AbstractLPCMFormat}, samples::Samples,
      recording::UUID, start::Period; custom...)</code></pre><p>Serialize the given <code>samples</code> to <code>file_format</code> and write the output to <code>file_path</code>, returning a <code>Signal</code> instance constructed from the provided arguments (any provided <code>custom</code> keyword arguments are forwarded to an invocation of the <code>Signal</code> constructor).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/samples.jl#L477-L484">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel-Tuple{Samples, Any}" href="#Onda.channel-Tuple{Samples, Any}"><code>Onda.channel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">channel(samples::Samples, name)</code></pre><p>Return <code>channel(samples.info, name)</code>.</p><p>This function is useful for indexing rows of <code>samples.data</code> by channel names.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/samples.jl#L96-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel-Tuple{Samples, Integer}" href="#Onda.channel-Tuple{Samples, Integer}"><code>Onda.channel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">channel(samples::Samples, i::Integer)</code></pre><p>Return <code>channel(samples.info, i)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/samples.jl#L105-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel_count-Tuple{Samples}" href="#Onda.channel_count-Tuple{Samples}"><code>Onda.channel_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">channel_count(samples::Samples)</code></pre><p>Return <code>channel_count(samples.info)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/samples.jl#L112-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.sample_count-Tuple{Samples}" href="#Onda.sample_count-Tuple{Samples}"><code>Onda.sample_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sample_count(samples::Samples)</code></pre><p>Return the number of multichannel samples in <code>samples</code> (i.e. <code>size(samples.data, 2)</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/samples.jl#L119-L123">source</a></section></article><h2 id="LPCM-(De)serialization-API-1"><a class="docs-heading-anchor" href="#LPCM-(De)serialization-API-1">LPCM (De)serialization API</a><a class="docs-heading-anchor-permalink" href="#LPCM-(De)serialization-API-1" title="Permalink"></a></h2><p>Onda.jl&#39;s LPCM (De)serialization API facilitates low-level streaming sample data (de)serialization and provides a storage-agnostic abstraction layer that can be overloaded to support new file/byte formats for (de)serializing LPCM-encodeable sample data.</p><article class="docstring"><header><a class="docstring-binding" id="Onda.AbstractLPCMFormat" href="#Onda.AbstractLPCMFormat"><code>Onda.AbstractLPCMFormat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractLPCMFormat</code></pre><p>A type whose subtypes represents byte/stream formats that can be (de)serialized to/from Onda&#39;s standard interleaved LPCM representation.</p><p>All subtypes of the form <code>F&lt;:AbstractLPCMFormat</code> must call <a href="#Onda.register_lpcm_format!"><code>Onda.register_lpcm_format!</code></a> and define an appropriate <a href="#Onda.file_format_string"><code>file_format_string</code></a> method.</p><p>See also:</p><ul><li><a href="#Onda.format"><code>format</code></a></li><li><a href="#Onda.deserialize_lpcm"><code>deserialize_lpcm</code></a></li><li><a href="#Onda.deserialize_lpcm_callback"><code>deserialize_lpcm_callback</code></a></li><li><a href="#Onda.serialize_lpcm"><code>serialize_lpcm</code></a></li><li><a href="#Onda.LPCMFormat"><code>LPCMFormat</code></a></li><li><a href="#Onda.LPCMZstFormat"><code>LPCMZstFormat</code></a></li><li><a href="#Onda.AbstractLPCMStream"><code>AbstractLPCMStream</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/serialization.jl#L43-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.AbstractLPCMStream" href="#Onda.AbstractLPCMStream"><code>Onda.AbstractLPCMStream</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractLPCMStream</code></pre><p>A type that represents an LPCM (de)serialization stream.</p><p>See also:</p><ul><li><a href="#Onda.deserializing_lpcm_stream"><code>deserializing_lpcm_stream</code></a></li><li><a href="#Onda.serializing_lpcm_stream"><code>serializing_lpcm_stream</code></a></li><li><a href="#Onda.finalize_lpcm_stream"><code>finalize_lpcm_stream</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/serialization.jl#L64-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.LPCMFormat" href="#Onda.LPCMFormat"><code>Onda.LPCMFormat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LPCMFormat(channel_count::Int, sample_type::Type)
LPCMFormat(info::SamplesInfo)</code></pre><p>Return a <code>LPCMFormat&lt;:AbstractLPCMFormat</code> instance corresponding to Onda&#39;s default interleaved LPCM format assumed for sample data files with the &quot;lpcm&quot; extension.</p><p><code>channel_count</code> corresponds to <code>length(info.channels)</code>, while <code>sample_type</code> corresponds to <code>sample_type(info)</code></p><p>Note that bytes (de)serialized to/from this format are little-endian (per the Onda specification).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/serialization.jl#L207-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.LPCMZstFormat" href="#Onda.LPCMZstFormat"><code>Onda.LPCMZstFormat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LPCMZstFormat(lpcm::LPCMFormat; level=3)
LPCMZstFormat(info::SamplesInfo; level=3)</code></pre><p>Return a <code>LPCMZstFormat&lt;:AbstractLPCMFormat</code> instance that corresponds to Onda&#39;s default interleaved LPCM format compressed by <code>zstd</code>. This format is assumed for sample data files with the &quot;lpcm.zst&quot; extension.</p><p>The <code>level</code> keyword argument sets the same compression level parameter as the corresponding flag documented by the <code>zstd</code> command line utility.</p><p>See https://facebook.github.io/zstd/ for details about <code>zstd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/serialization.jl#L304-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.format" href="#Onda.format"><code>Onda.format</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">format(file_format::AbstractString, info::SamplesInfo; kwargs...)</code></pre><p>Return <code>f(info; kwargs...)</code> where <code>f</code> constructs the <code>AbstractLPCMFormat</code> instance that corresponds to <code>file_format</code>. <code>f</code> is determined by matching <code>file_format</code> to a suitable format constuctor registered via <a href="#Onda.register_lpcm_format!"><code>register_lpcm_format!</code></a>.</p><p>See also: <a href="#Onda.deserialize_lpcm"><code>deserialize_lpcm</code></a>, <a href="#Onda.serialize_lpcm"><code>serialize_lpcm</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/serialization.jl#L25-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.deserialize_lpcm" href="#Onda.deserialize_lpcm"><code>Onda.deserialize_lpcm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">deserialize_lpcm(format::AbstractLPCMFormat, bytes,
                 samples_offset::Integer=0,
                 samples_count::Integer=typemax(Int))
deserialize_lpcm(stream::AbstractLPCMStream,
                 samples_offset::Integer=0,
                 samples_count::Integer=typemax(Int))</code></pre><p>Return a channels-by-timesteps <code>AbstractMatrix</code> of interleaved LPCM-encoded sample data by deserializing the provided <code>bytes</code> in the given <code>format</code>, or from the given <code>stream</code> constructed by <a href="#Onda.deserializing_lpcm_stream"><code>deserializing_lpcm_stream</code></a>.</p><p>Note that this operation may be performed in a zero-copy manner such that the returned sample matrix directly aliases <code>bytes</code>.</p><p>The returned segment is at most <code>sample_offset</code> samples offset from the start of <code>stream</code>/<code>bytes</code> and contains at most <code>sample_count</code> samples. This ensures that overrun behavior is generally similar to the behavior of <code>Base.skip(io, n)</code> and <code>Base.read(io, n)</code>.</p><p>This function is the inverse of the corresponding <a href="#Onda.serialize_lpcm"><code>serialize_lpcm</code></a> method, i.e.:</p><pre><code class="language-none">serialize_lpcm(format, deserialize_lpcm(format, bytes)) == bytes</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/serialization.jl#L130-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.serialize_lpcm" href="#Onda.serialize_lpcm"><code>Onda.serialize_lpcm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">serialize_lpcm(format::AbstractLPCMFormat, samples::AbstractMatrix)
serialize_lpcm(stream::AbstractLPCMStream, samples::AbstractMatrix)</code></pre><p>Return the <code>AbstractVector{UInt8}</code> of bytes that results from serializing <code>samples</code> to the given <code>format</code> (or serialize those bytes directly to <code>stream</code>) where <code>samples</code> is a channels-by-timesteps matrix of interleaved LPCM-encoded sample data.</p><p>Note that this operation may be performed in a zero-copy manner such that the returned <code>AbstractVector{UInt8}</code> directly aliases <code>samples</code>.</p><p>This function is the inverse of the corresponding <a href="#Onda.deserialize_lpcm"><code>deserialize_lpcm</code></a> method, i.e.:</p><pre><code class="language-none">deserialize_lpcm(format, serialize_lpcm(format, samples)) == samples</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/serialization.jl#L158-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.deserialize_lpcm_callback" href="#Onda.deserialize_lpcm_callback"><code>Onda.deserialize_lpcm_callback</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">deserialize_lpcm_callback(format::AbstractLPCMFormat, samples_offset, samples_count)</code></pre><p>Return <code>(callback, required_byte_offset, required_byte_count)</code> where <code>callback</code> accepts the byte block specified by <code>required_byte_offset</code> and <code>required_byte_count</code> and returns the samples specified by <code>samples_offset</code> and <code>samples_count</code>.</p><p>As a fallback, this function returns <code>(callback, missing, missing)</code>, where <code>callback</code> requires all available bytes. <code>AbstractLPCMFormat</code> subtypes that support partial/block-based deserialization (e.g. the basic <code>LPCMFormat</code>) can overload this function to only request exactly the byte range that is required for the sample range requested by the caller.</p><p>This allows callers to handle the byte block retrieval themselves while keeping Onda&#39;s LPCM Serialization API agnostic to the caller&#39;s storage layer of choice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/serialization.jl#L77-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.deserializing_lpcm_stream" href="#Onda.deserializing_lpcm_stream"><code>Onda.deserializing_lpcm_stream</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">deserializing_lpcm_stream(format::AbstractLPCMFormat, io)</code></pre><p>Return a <code>stream::AbstractLPCMStream</code> that wraps <code>io</code> to enable direct LPCM deserialization from <code>io</code> via <a href="#Onda.deserialize_lpcm"><code>deserialize_lpcm</code></a>.</p><p>Note that <code>stream</code> must be finalized after usage via <a href="#Onda.finalize_lpcm_stream"><code>finalize_lpcm_stream</code></a>. Until <code>stream</code> is finalized, <code>io</code> should be considered to be part of the internal state of <code>stream</code> and should not be directly interacted with by other processes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/serialization.jl#L97-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.serializing_lpcm_stream" href="#Onda.serializing_lpcm_stream"><code>Onda.serializing_lpcm_stream</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">serializing_lpcm_stream(format::AbstractLPCMFormat, io)</code></pre><p>Return a <code>stream::AbstractLPCMStream</code> that wraps <code>io</code> to enable direct LPCM serialization to <code>io</code> via <a href="#Onda.serialize_lpcm"><code>serialize_lpcm</code></a>.</p><p>Note that <code>stream</code> must be finalized after usage via <a href="#Onda.finalize_lpcm_stream"><code>finalize_lpcm_stream</code></a>. Until <code>stream</code> is finalized, <code>io</code> should be considered to be part of the internal state of <code>stream</code> and should not be directly interacted with by other processes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/serialization.jl#L109-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.finalize_lpcm_stream" href="#Onda.finalize_lpcm_stream"><code>Onda.finalize_lpcm_stream</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">finalize_lpcm_stream(stream::AbstractLPCMStream)::Bool</code></pre><p>Finalize <code>stream</code>, returning <code>true</code> if the underlying I/O object used to construct <code>stream</code> is still open and usable. Otherwise, return <code>false</code> to indicate that underlying I/O object was closed as result of finalization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/serialization.jl#L121-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.register_lpcm_format!" href="#Onda.register_lpcm_format!"><code>Onda.register_lpcm_format!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Onda.register_lpcm_format!(create_constructor)</code></pre><p>Register an <code>AbstractLPCMFormat</code> constructor so that it can automatically be used when <a href="#Onda.format"><code>format</code></a> is called. Authors of new <code>AbstractLPCMFormat</code> subtypes should call this function for their subtype.</p><p><code>create_constructor</code> should be a unary function that accepts a single <code>file_format::AbstractString</code> argument, and return either a matching <code>AbstractLPCMFormat</code> constructor or <code>nothing</code>. Any returned <code>AbstractLPCMFormat</code> constructor <code>f</code> should be of the form <code>f(info::SamplesInfo; kwargs...)::AbstractLPCMFormat</code>.</p><p>Note that if <code>Onda.register_lpcm_format!</code> is called in a downstream package, it must be called within the <code>__init__</code> function of the package&#39;s top-level module to ensure that the function is always invoked when the module is loaded (not just during precompilation). For details, see https://docs.julialang.org/en/v1/manual/modules/#Module-initialization-and-precompilation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/serialization.jl#L7-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.file_format_string" href="#Onda.file_format_string"><code>Onda.file_format_string</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">file_format_string(format::AbstractLPCMFormat)</code></pre><p>Return the <code>String</code> representation of <code>format</code> to be written to the <code>file_format</code> field of a <code>*.signals</code> file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/serialization.jl#L178-L182">source</a></section></article><h2 id="Utilities-1"><a class="docs-heading-anchor" href="#Utilities-1">Utilities</a><a class="docs-heading-anchor-permalink" href="#Utilities-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Onda.VALIDATE_SAMPLES_DEFAULT" href="#Onda.VALIDATE_SAMPLES_DEFAULT"><code>Onda.VALIDATE_SAMPLES_DEFAULT</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">VALIDATE_SAMPLES_DEFAULT[]</code></pre><p>Defaults to <code>true</code>.</p><p>When set to <code>true</code>, <code>Samples</code> objects will be validated upon construction for compliance with the Onda specification.</p><p>Users may interactively set this reference to <code>false</code> in order to disable this extra layer validation, which can be useful when working with malformed Onda datasets.</p><p>See also: <a href="@ref"><code>Onda.validate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/0fad24ceb61f77476140fcc1b09a8b2fb17b1ce2/src/samples.jl#L5-L17">source</a></section></article><h2 id="Developer-Installation-1"><a class="docs-heading-anchor" href="#Developer-Installation-1">Developer Installation</a><a class="docs-heading-anchor-permalink" href="#Developer-Installation-1" title="Permalink"></a></h2><p>To install Onda for development, run:</p><pre><code class="language-none">julia -e &#39;using Pkg; Pkg.develop(&quot;Onda&quot;)&#39;</code></pre><p>This will install Onda to the default package development directory, <code>~/.julia/dev/Onda</code>.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="upgrading/">Upgrading From Older Versions Of Onda »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 4 August 2021 19:10">Wednesday 4 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
