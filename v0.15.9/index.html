<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Documentation · Onda</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Onda</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>API Documentation</a><ul class="internal"><li><a class="tocitem" href="#Support-For-Generic-Path-Like-Types"><span>Support For Generic Path-Like Types</span></a></li><li><a class="tocitem" href="#onda.annotation"><span><code>onda.annotation</code></span></a></li><li><a class="tocitem" href="#onda.signal"><span><code>onda.signal</code></span></a></li><li><a class="tocitem" href="#Samples"><span><code>Samples</code></span></a></li><li><a class="tocitem" href="#LPCM-(De)serialization-API"><span>LPCM (De)serialization API</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li><a class="tocitem" href="#Developer-Installation"><span>Developer Installation</span></a></li></ul></li><li><a class="tocitem" href="upgrading/">Upgrading From Older Versions Of Onda</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/beacon-biosignals/Onda.jl/blob/main/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Documentation"><a class="docs-heading-anchor" href="#API-Documentation">API Documentation</a><a id="API-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#API-Documentation" title="Permalink"></a></h1><p>We highly recommend that newcomers walk through the <a href="https://github.com/beacon-biosignals/Onda.jl/blob/master/examples/tour.jl">Onda Tour</a> before diving into this reference documentation.</p><h2 id="Support-For-Generic-Path-Like-Types"><a class="docs-heading-anchor" href="#Support-For-Generic-Path-Like-Types">Support For Generic Path-Like Types</a><a id="Support-For-Generic-Path-Like-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Support-For-Generic-Path-Like-Types" title="Permalink"></a></h2><p>Onda.jl attempts to be as agnostic as possible with respect to the storage system that sample data, Arrow files, etc. are read from/written to. As such, any path-like argument accepted by an Onda.jl API function should generically &quot;work&quot; as long as the argument&#39;s type supports:</p><ul><li><code>Base.read(path)::Vector{UInt8}</code> (return the bytes stored at <code>path</code>)</li><li><code>Base.write(path, bytes::Vector{UInt8})</code> (write <code>bytes</code> to the location specified by <code>path</code>)</li></ul><p>For backends which support direct byte range access (e.g. S3), <code>Onda.read_byte_range</code> may be overloaded for the backend&#39;s corresponding path type to enable further optimizations:</p><article class="docstring"><header><a class="docstring-binding" id="Onda.read_byte_range" href="#Onda.read_byte_range"><code>Onda.read_byte_range</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_byte_range(path, byte_offset, byte_count)</code></pre><p>Return the equivalent <code>read(path)[(byte_offset + 1):(byte_offset + byte_count)]</code>, but try to avoid reading unreturned intermediate bytes. Note that the effectiveness of this method depends on the type of <code>path</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/utilities.jl#L93-L99">source</a></section></article><h2 id="onda.annotation"><a class="docs-heading-anchor" href="#onda.annotation"><code>onda.annotation</code></a><a id="onda.annotation-1"></a><a class="docs-heading-anchor-permalink" href="#onda.annotation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Onda.AnnotationV1" href="#Onda.AnnotationV1"><code>Onda.AnnotationV1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@version AnnotationV1 begin
    recording::UUID
    id::UUID
    span::TimeSpan
end</code></pre><p>A Legolas-generated record type representing an <a href="https://github.com/beacon-biosignals/Onda.jl##ondaannotation1"><code>onda.annotation</code> as described by the Onda Format Specification</a>.</p><p>See https://github.com/beacon-biosignals/Legolas.jl for details regarding Legolas record types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/annotations.jl#L15-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.MergedAnnotationV1" href="#Onda.MergedAnnotationV1"><code>Onda.MergedAnnotationV1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@version MergedAnnotationV1 &gt; AnnotationV1 begin
    from::Vector{UUID}
end</code></pre><p>A Legolas-generated record type representing an annotation derived from &quot;merging&quot; one or more existing annotations.</p><p>This record type extends <code>AnnotationV1</code> with a single additional required field, <code>from::Vector{UUID}</code>, whose entries are the <code>id</code>s of the annotation&#39;s source annotation(s).</p><p>See https://github.com/beacon-biosignals/Legolas.jl for details regarding Legolas record types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/annotations.jl#L52-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.merge_overlapping_annotations" href="#Onda.merge_overlapping_annotations"><code>Onda.merge_overlapping_annotations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">merge_overlapping_annotations([predicate=TimeSpans.overlaps,] annotations)</code></pre><p>Given the <code>onda.annotation@1</code>-compliant table <code>annotations</code>, return a <code>Vector{MergedAnnotationV1}</code> where &quot;overlapping&quot; consecutive entries of <code>annotations</code> have been merged using <code>TimeSpans.shortest_timespan_containing</code>.</p><p>Two consecutive annotations <code>a</code> and <code>b</code> are determined to be &quot;overlapping&quot; if <code>a.recording == b.recording &amp;&amp; predicate(a.span, b.span)</code>. Merged annotations&#39; <code>span</code> fields are generated via calling <code>TimeSpans.shortest_timespan_containing</code> on the overlapping set of source annotations.</p><p>Note that every annotation in the returned table has a freshly generated <code>id</code> field and a non-empty <code>from</code> field. An output annotation whose <code>from</code> field only a contains a single element corresponds to an individual non-overlapping annotation in the provided <code>annotations</code>.</p><p>Note that this function internally works with <code>Tables.columns(annotations)</code> rather than <code>annotations</code> directly, so it may be slower and/or require more memory if <code>!Tables.columnaccess(annotations)</code>.</p><p>See also <code>TimeSpans.merge_spans</code> for similar functionality on generic time spans (instead of annotations).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/annotations.jl#L66-L83">source</a></section></article><h2 id="onda.signal"><a class="docs-heading-anchor" href="#onda.signal"><code>onda.signal</code></a><a id="onda.signal-1"></a><a class="docs-heading-anchor-permalink" href="#onda.signal" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Onda.SignalV2" href="#Onda.SignalV2"><code>Onda.SignalV2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@version SignalV2 &gt; SamplesInfoV2 begin
    recording::UUID
    file_path::(&lt;:Any)
    file_format::String
    span::TimeSpan
    sensor_label::String
    sensor_type::String
    channels::Vector{String}
    sample_unit::String
end</code></pre><p>A Legolas-generated record type representing an <a href="https://github.com/beacon-biosignals/Onda.jl##ondasignal2"><code>onda.signal</code> as described by the Onda Format Specification</a>.</p><p>Note that some fields documented as required fields of <code>onda.signal@2</code> in the Onda Format Specification are captured via this schema version&#39;s extension of <code>SamplesInfoV2</code>.</p><p>See https://github.com/beacon-biosignals/Legolas.jl for details regarding Legolas record types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/signals.jl#L136-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.SamplesInfoV2" href="#Onda.SamplesInfoV2"><code>Onda.SamplesInfoV2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@version SamplesInfoV2 begin
    sensor_type::String
    channels::Vector{String}
    sample_unit::String
    sample_resolution_in_unit::Float64
    sample_offset_in_unit::Float64
    sample_type::String = onda_sample_type_from_julia_type(sample_type)
    sample_rate::Float64
end</code></pre><p>A Legolas-generated record type representing the bundle of <code>onda.signal</code> fields that are intrinsic to a signal&#39;s sample data, leaving out extrinsic file or recording information. This is useful when the latter information is irrelevant or does not yet exist (e.g. if sample data is being constructed/manipulated in-memory without yet having been serialized).</p><p>See https://github.com/beacon-biosignals/Legolas.jl for details regarding Legolas record types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/signals.jl#L89-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel-Tuple{Any, Any}" href="#Onda.channel-Tuple{Any, Any}"><code>Onda.channel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">channel(x, name)</code></pre><p>Return <code>i</code> where <code>x.channels[i] == name</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/signals.jl#L175-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel-Tuple{Any, Integer}" href="#Onda.channel-Tuple{Any, Integer}"><code>Onda.channel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">channel(x, i::Integer)</code></pre><p>Return <code>x.channels[i]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/signals.jl#L182-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel_count-Tuple{Any}" href="#Onda.channel_count-Tuple{Any}"><code>Onda.channel_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">channel_count(x)</code></pre><p>Return <code>length(x.channels)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/signals.jl#L189-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.sample_count-Tuple{Any, Dates.Period}" href="#Onda.sample_count-Tuple{Any, Dates.Period}"><code>Onda.sample_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_count(x, duration::Period)</code></pre><p>Return the number of multichannel samples that fit within <code>duration</code> given <code>x.sample_rate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/signals.jl#L196-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.sizeof_samples-Tuple{Any, Dates.Period}" href="#Onda.sizeof_samples-Tuple{Any, Dates.Period}"><code>Onda.sizeof_samples</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sizeof_samples(x, duration::Period)</code></pre><p>Returns the expected size (in bytes) of an encoded <code>Samples</code> object corresponding to <code>x</code> and <code>duration</code>:</p><pre><code class="nohighlight hljs">sample_count(x, duration) * channel_count(x) * sizeof(x.sample_type)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/signals.jl#L210-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.sample_type-Tuple{Any}" href="#Onda.sample_type-Tuple{Any}"><code>Onda.sample_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_type(x)</code></pre><p>Return <code>x.sample_type</code> as an <code>Onda.LPCM_SAMPLE_TYPE_UNION</code> subtype. If <code>x.sample_type</code> is an Onda-specified <code>sample_type</code> string (e.g. <code>&quot;int16&quot;</code>), it will be converted to the corresponding Julia type. If <code>x.sample_type &lt;: Onda.LPCM_SAMPLE_TYPE_UNION</code>, this function simply returns <code>x.sample_type</code> as-is.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/signals.jl#L203-L207">source</a></section></article><h2 id="Samples"><a class="docs-heading-anchor" href="#Samples"><code>Samples</code></a><a id="Samples-1"></a><a class="docs-heading-anchor-permalink" href="#Samples" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Onda.Samples" href="#Onda.Samples"><code>Onda.Samples</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Samples(data::AbstractMatrix, info::SamplesInfoV2, encoded::Bool;
        validate::Bool=Onda.VALIDATE_SAMPLES_DEFAULT[])</code></pre><p>Return a <code>Samples</code> instance with the following fields:</p><ul><li><p><code>data::AbstractMatrix</code>: A matrix of sample data. The <code>i</code> th row of the matrix corresponds to the <code>i</code>th channel in <code>info.channels</code>, while the <code>j</code>th column corresponds to the <code>j</code>th multichannel sample.</p></li><li><p><code>info::SamplesInfoV2</code>: The <a href="#Onda.SamplesInfoV2"><code>SamplesInfoV2</code></a>-compliant value that describes the <code>Samples</code> instance.</p></li><li><p><code>encoded::Bool</code>: If <code>true</code>, the values in <code>data</code> are LPCM-encoded as prescribed by the <code>Samples</code> instance&#39;s <code>info</code>. If <code>false</code>, the values in <code>data</code> have been decoded into the <code>info</code>&#39;s canonical units.</p></li></ul><p>If <code>validate</code> is <code>true</code>, <a href="@ref"><code>Onda.validate_samples</code></a> is called on the constructed <code>Samples</code> instance before it is returned.</p><p>Note that <code>getindex</code> and <code>view</code> are defined on <code>Samples</code> to accept normal integer indices, but also accept channel names or a regex to match channel names for row indices, and <code>TimeSpan</code> values for column indices; see <code>Onda/examples/tour.jl</code> for a comprehensive set of indexing examples.</p><p>Note also that &quot;slices&quot; copied from <code>s::Samples</code> via <code>getindex(s, ...)</code> may alias <code>s.info</code> in order to avoid excessive overhead. This means one should generally avoid directly mutating <code>s.info</code>, especially <code>s.info.channels</code>.</p><p>See also: <a href="#Onda.load"><code>load</code></a>, <a href="#Onda.store"><code>store</code></a>, <a href="#Onda.encode"><code>encode</code></a>, <a href="#Onda.encode!"><code>encode!</code></a>, <a href="#Onda.decode"><code>decode</code></a>, <a href="#Onda.decode!"><code>decode!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/samples.jl#L20-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{Samples, Samples}" href="#Base.:==-Tuple{Samples, Samples}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(a::Samples, b::Samples)</code></pre><p>Returns <code>a.encoded == b.encoded &amp;&amp; a.info == b.info &amp;&amp; a.data == b.data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/samples.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel" href="#Onda.channel"><code>Onda.channel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">channel(x, name)</code></pre><p>Return <code>i</code> where <code>x.channels[i] == name</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/signals.jl#L175-L179">source</a></section><section><div><pre><code class="language-julia hljs">channel(x, i::Integer)</code></pre><p>Return <code>x.channels[i]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/signals.jl#L182-L186">source</a></section><section><div><pre><code class="language-julia hljs">channel(samples::Samples, name)</code></pre><p>Return <code>channel(samples.info, name)</code>.</p><p>This function is useful for indexing rows of <code>samples.data</code> by channel names.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/samples.jl#L130-L136">source</a></section><section><div><pre><code class="language-julia hljs">channel(samples::Samples, i::Integer)</code></pre><p>Return <code>channel(samples.info, i)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/samples.jl#L139-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel_count" href="#Onda.channel_count"><code>Onda.channel_count</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">channel_count(x)</code></pre><p>Return <code>length(x.channels)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/signals.jl#L189-L193">source</a></section><section><div><pre><code class="language-julia hljs">channel_count(samples::Samples)</code></pre><p>Return <code>channel_count(samples.info)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/samples.jl#L146-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.sample_count" href="#Onda.sample_count"><code>Onda.sample_count</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sample_count(x, duration::Period)</code></pre><p>Return the number of multichannel samples that fit within <code>duration</code> given <code>x.sample_rate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/signals.jl#L196-L200">source</a></section><section><div><pre><code class="language-julia hljs">sample_count(samples::Samples)</code></pre><p>Return the number of multichannel samples in <code>samples</code> (i.e. <code>size(samples.data, 2)</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/samples.jl#L153-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.encode" href="#Onda.encode"><code>Onda.encode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">encode(sample_type::DataType, sample_resolution_in_unit, sample_offset_in_unit,
       sample_data, dither_storage=nothing)</code></pre><p>Return a copy of <code>sample_data</code> quantized according to <code>sample_type</code>, <code>sample_resolution_in_unit</code>, and <code>sample_offset_in_unit</code>. <code>sample_type</code> must be a concrete subtype of <code>Onda.LPCM_SAMPLE_TYPE_UNION</code>. Quantization of an individual sample <code>s</code> is performed via:</p><pre><code class="nohighlight hljs">round(S, (s - sample_offset_in_unit) / sample_resolution_in_unit)</code></pre><p>with additional special casing to clip values exceeding the encoding&#39;s dynamic range.</p><p>If <code>dither_storage isa Nothing</code>, no dithering is applied before quantization.</p><p>If <code>dither_storage isa Missing</code>, dither storage is allocated automatically and triangular dithering is applied to the info prior to quantization.</p><p>Otherwise, <code>dither_storage</code> must be a container of similar shape and type to <code>sample_data</code>. This container is then used to store the random noise needed for the triangular dithering process, which is applied to the info prior to quantization.</p><p>If:</p><pre><code class="nohighlight hljs">sample_type === eltype(sample_data) &amp;&amp;
sample_resolution_in_unit == 1 &amp;&amp;
sample_offset_in_unit == 0</code></pre><p>then this function will simply return <code>sample_data</code> directly without copying/dithering.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/samples.jl#L260-L288">source</a></section><section><div><pre><code class="nohighlight hljs">encode(samples::Samples, dither_storage=nothing)</code></pre><p>If <code>samples.encoded</code> is <code>false</code>, return a <code>Samples</code> instance that wraps:</p><pre><code class="nohighlight hljs">encode(sample_type(samples.info),
       samples.info.sample_resolution_in_unit,
       samples.info.sample_offset_in_unit,
       samples.data, dither_storage)</code></pre><p>If <code>samples.encoded</code> is <code>true</code>, this function is the identity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/samples.jl#L352-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.encode!" href="#Onda.encode!"><code>Onda.encode!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">encode!(result_storage, sample_type::DataType, sample_resolution_in_unit,
        sample_offset_in_unit, sample_data, dither_storage=nothing)
encode!(result_storage, sample_resolution_in_unit, sample_offset_in_unit,
        sample_data, dither_storage=nothing)</code></pre><p>Similar to <code>encode(sample_type, sample_resolution_in_unit, sample_offset_in_unit, sample_data, dither_storage)</code>, but write encoded values to <code>result_storage</code> rather than allocating new storage.</p><p><code>sample_type</code> defaults to <code>eltype(result_storage)</code> if it is not provided.</p><p>If:</p><pre><code class="nohighlight hljs">sample_type === eltype(sample_data) &amp;&amp;
sample_resolution_in_unit == 1 &amp;&amp;
sample_offset_in_unit == 0</code></pre><p>then this function will simply copy <code>sample_data</code> directly into <code>result_storage</code> without dithering.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/samples.jl#L301-L319">source</a></section><section><div><pre><code class="nohighlight hljs">encode!(result_storage, samples::Samples, dither_storage=nothing)</code></pre><p>If <code>samples.encoded</code> is <code>false</code>, return a <code>Samples</code> instance that wraps:</p><pre><code class="nohighlight hljs">encode!(result_storage,
        sample_type(samples.info),
        samples.info.sample_resolution_in_unit,
        samples.info.sample_offset_in_unit,
        samples.data, dither_storage)`.</code></pre><p>If <code>samples.encoded</code> is <code>true</code>, return a <code>Samples</code> instance that wraps <code>copyto!(result_storage, samples.data)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/samples.jl#L373-L386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.decode" href="#Onda.decode"><code>Onda.decode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">decode(sample_resolution_in_unit, sample_offset_in_unit, sample_data)</code></pre><p>Return <code>fma.(sample_resolution_in_unit, sample_data, sample_offset_in_unit)</code>.</p><p>If:</p><pre><code class="nohighlight hljs">sample_data isa AbstractArray &amp;&amp;
sample_resolution_in_unit == 1 &amp;&amp;
sample_offset_in_unit == 0</code></pre><p>then this function is the identity and will return <code>sample_data</code> directly without copying.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/samples.jl#L403-L415">source</a></section><section><div><pre><code class="nohighlight hljs">decode(samples::Samples, ::Type{T}=Float64)</code></pre><p>If <code>samples.encoded</code> is <code>true</code>, return a <code>Samples</code> instance that wraps</p><pre><code class="nohighlight hljs">decode(convert(T, samples.info.sample_resolution_in_unit),
       convert(T, samples.info.sample_offset_in_unit),
       samples.data)</code></pre><p>If <code>samples.encoded</code> is <code>false</code>, this function is the identity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/samples.jl#L434-L444">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.decode!" href="#Onda.decode!"><code>Onda.decode!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">decode!(result_storage, sample_resolution_in_unit, sample_offset_in_unit, sample_data)</code></pre><p>Similar to <code>decode(sample_resolution_in_unit, sample_offset_in_unit, sample_data)</code>, but write decoded values to <code>result_storage</code> rather than allocating new storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/samples.jl#L423-L428">source</a></section><section><div><pre><code class="nohighlight hljs">decode!(result_storage, samples::Samples)</code></pre><p>If <code>samples.encoded</code> is <code>true</code>, return a <code>Samples</code> instance that wraps</p><pre><code class="nohighlight hljs">decode!(result_storage, samples.info.sample_resolution_in_unit, samples.info.sample_offset_in_unit, samples.data)</code></pre><p>If <code>samples.encoded</code> is <code>false</code>, return a <code>Samples</code> instance that wraps <code>copyto!(result_storage, samples.data)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/samples.jl#L453-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.load" href="#Onda.load"><code>Onda.load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load(signal[, span_relative_to_loaded_samples]; encoded::Bool=false)
load(file_path, file_format::Union{AbstractString,AbstractLPCMFormat},
     info[, span_relative_to_loaded_samples]; encoded::Bool=false)</code></pre><p>Return the <code>Samples</code> object described by <code>signal</code>/<code>file_path</code>/<code>file_format</code>/<code>info</code>.</p><p>If <code>span_relative_to_loaded_samples</code> is present, return <code>load(...)[:, span_relative_to_loaded_samples]</code>, but attempt to avoid reading unreturned intermediate sample data. Note that the effectiveness of this optimized method versus the naive approach depends on the types of <code>file_path</code> (i.e. if there is a fast method defined for <code>Onda.read_byte_range(::typeof(file_path), ...)</code>) and <code>file_format</code> (i.e. does the corresponding format support random or chunked access).</p><p>If <code>encoded</code> is <code>true</code>, do not decode the <code>Samples</code> object before returning it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/samples.jl#L476-L490">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.mmap" href="#Onda.mmap"><code>Onda.mmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Onda.mmap(signal)</code></pre><p>Return <code>Onda.mmap(signal.file_path, SamplesInfoV2(signal))</code>, throwing an <code>ArgumentError</code> if <code>signal.file_format != &quot;lpcm&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/samples.jl#L526-L530">source</a></section><section><div><pre><code class="nohighlight hljs">Onda.mmap(mmappable, info)</code></pre><p>Return <code>Samples(data, info, true)</code> where <code>data</code> is created via <code>Mmap.mmap(mmappable, ...)</code>.</p><p><code>mmappable</code> is assumed to reference memory that is formatted according to the Onda Format&#39;s canonical interleaved LPCM representation in accordance with <code>sample_type(info)</code> and <code>channel_count(info)</code>. No explicit checks are performed to ensure that this is true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/samples.jl#L536-L544">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.store" href="#Onda.store"><code>Onda.store</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">store(file_path, file_format::Union{AbstractString,AbstractLPCMFormat}, samples::Samples)</code></pre><p>Serialize the given <code>samples</code> to <code>file_format</code> and write the output to <code>file_path</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/samples.jl#L550-L554">source</a></section><section><div><pre><code class="nohighlight hljs">store(file_path, file_format::Union{AbstractString,AbstractLPCMFormat},
      samples::Samples, recording::UUID, start::Period,
      sensor_label::AbstractString = samples.info.sensor_type)</code></pre><p>Serialize the given <code>samples</code> to <code>file_format</code> and write the output to <code>file_path</code>, returning a <code>SignalV2</code> instance constructed from the provided arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/samples.jl#L560-L567">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel-Tuple{Samples, Any}" href="#Onda.channel-Tuple{Samples, Any}"><code>Onda.channel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">channel(samples::Samples, name)</code></pre><p>Return <code>channel(samples.info, name)</code>.</p><p>This function is useful for indexing rows of <code>samples.data</code> by channel names.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/samples.jl#L130-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel-Tuple{Samples, Integer}" href="#Onda.channel-Tuple{Samples, Integer}"><code>Onda.channel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">channel(samples::Samples, i::Integer)</code></pre><p>Return <code>channel(samples.info, i)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/samples.jl#L139-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.channel_count-Tuple{Samples}" href="#Onda.channel_count-Tuple{Samples}"><code>Onda.channel_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">channel_count(samples::Samples)</code></pre><p>Return <code>channel_count(samples.info)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/samples.jl#L146-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.sample_count-Tuple{Samples}" href="#Onda.sample_count-Tuple{Samples}"><code>Onda.sample_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_count(samples::Samples)</code></pre><p>Return the number of multichannel samples in <code>samples</code> (i.e. <code>size(samples.data, 2)</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/samples.jl#L153-L157">source</a></section></article><h2 id="LPCM-(De)serialization-API"><a class="docs-heading-anchor" href="#LPCM-(De)serialization-API">LPCM (De)serialization API</a><a id="LPCM-(De)serialization-API-1"></a><a class="docs-heading-anchor-permalink" href="#LPCM-(De)serialization-API" title="Permalink"></a></h2><p>Onda.jl&#39;s LPCM (De)serialization API facilitates low-level streaming sample data (de)serialization and provides a storage-agnostic abstraction layer that can be overloaded to support new file/byte formats for (de)serializing LPCM-encodeable sample data.</p><article class="docstring"><header><a class="docstring-binding" id="Onda.AbstractLPCMFormat" href="#Onda.AbstractLPCMFormat"><code>Onda.AbstractLPCMFormat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractLPCMFormat</code></pre><p>A type whose subtypes represents byte/stream formats that can be (de)serialized to/from Onda&#39;s standard interleaved LPCM representation.</p><p>All subtypes of the form <code>F&lt;:AbstractLPCMFormat</code> must call <a href="#Onda.register_lpcm_format!"><code>Onda.register_lpcm_format!</code></a> and define an appropriate <a href="#Onda.file_format_string"><code>file_format_string</code></a> method.</p><p>See also:</p><ul><li><a href="#Onda.format"><code>format</code></a></li><li><a href="#Onda.deserialize_lpcm"><code>deserialize_lpcm</code></a></li><li><a href="#Onda.deserialize_lpcm_callback"><code>deserialize_lpcm_callback</code></a></li><li><a href="#Onda.serialize_lpcm"><code>serialize_lpcm</code></a></li><li><a href="#Onda.LPCMFormat"><code>LPCMFormat</code></a></li><li><a href="#Onda.LPCMZstFormat"><code>LPCMZstFormat</code></a></li><li><a href="#Onda.AbstractLPCMStream"><code>AbstractLPCMStream</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/serialization.jl#L45-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.AbstractLPCMStream" href="#Onda.AbstractLPCMStream"><code>Onda.AbstractLPCMStream</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractLPCMStream</code></pre><p>A type that represents an LPCM (de)serialization stream.</p><p>See also:</p><ul><li><a href="#Onda.deserializing_lpcm_stream"><code>deserializing_lpcm_stream</code></a></li><li><a href="#Onda.serializing_lpcm_stream"><code>serializing_lpcm_stream</code></a></li><li><a href="#Onda.finalize_lpcm_stream"><code>finalize_lpcm_stream</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/serialization.jl#L66-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.LPCMFormat" href="#Onda.LPCMFormat"><code>Onda.LPCMFormat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LPCMFormat(channel_count::Int, sample_type::Type)
LPCMFormat(info::SamplesInfoV2)</code></pre><p>Return a <code>LPCMFormat&lt;:AbstractLPCMFormat</code> instance corresponding to Onda&#39;s default interleaved LPCM format assumed for sample data files with the &quot;lpcm&quot; extension.</p><p><code>channel_count</code> corresponds to <code>length(info.channels)</code>, while <code>sample_type</code> corresponds to <code>sample_type(info)</code></p><p>Note that bytes (de)serialized to/from this format are little-endian (per the Onda specification).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/serialization.jl#L209-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.LPCMZstFormat" href="#Onda.LPCMZstFormat"><code>Onda.LPCMZstFormat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LPCMZstFormat(lpcm::LPCMFormat; level=3)
LPCMZstFormat(info; level=3)</code></pre><p>Return a <code>LPCMZstFormat&lt;:AbstractLPCMFormat</code> instance that corresponds to Onda&#39;s default interleaved LPCM format compressed by <code>zstd</code>. This format is assumed for sample data files with the &quot;lpcm.zst&quot; extension.</p><p>The <code>level</code> keyword argument sets the same compression level parameter as the corresponding flag documented by the <code>zstd</code> command line utility.</p><p>See https://facebook.github.io/zstd/ for details about <code>zstd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/serialization.jl#L306-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.format" href="#Onda.format"><code>Onda.format</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">format(file_format::AbstractString, info; kwargs...)</code></pre><p>Return <code>f(info; kwargs...)</code> where <code>f</code> constructs the <code>AbstractLPCMFormat</code> instance that corresponds to <code>file_format</code> and info is a <a href="#Onda.SamplesInfoV2"><code>SamplesInfoV2</code></a>-compliant value. <code>f</code> is determined by matching <code>file_format</code> to a suitable format constuctor registered via <a href="#Onda.register_lpcm_format!"><code>register_lpcm_format!</code></a>.</p><p>See also: <a href="#Onda.deserialize_lpcm"><code>deserialize_lpcm</code></a>, <a href="#Onda.serialize_lpcm"><code>serialize_lpcm</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/serialization.jl#L26-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.deserialize_lpcm" href="#Onda.deserialize_lpcm"><code>Onda.deserialize_lpcm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deserialize_lpcm(format::AbstractLPCMFormat, bytes,
                 samples_offset::Integer=0,
                 samples_count::Integer=typemax(Int))
deserialize_lpcm(stream::AbstractLPCMStream,
                 samples_offset::Integer=0,
                 samples_count::Integer=typemax(Int))</code></pre><p>Return a channels-by-timesteps <code>AbstractMatrix</code> of interleaved LPCM-encoded sample data by deserializing the provided <code>bytes</code> in the given <code>format</code>, or from the given <code>stream</code> constructed by <a href="#Onda.deserializing_lpcm_stream"><code>deserializing_lpcm_stream</code></a>.</p><p>Note that this operation may be performed in a zero-copy manner such that the returned sample matrix directly aliases <code>bytes</code>.</p><p>The returned segment is at most <code>sample_offset</code> samples offset from the start of <code>stream</code>/<code>bytes</code> and contains at most <code>sample_count</code> samples. This ensures that overrun behavior is generally similar to the behavior of <code>Base.skip(io, n)</code> and <code>Base.read(io, n)</code>.</p><p>This function is the inverse of the corresponding <a href="#Onda.serialize_lpcm"><code>serialize_lpcm</code></a> method, i.e.:</p><pre><code class="nohighlight hljs">serialize_lpcm(format, deserialize_lpcm(format, bytes)) == bytes</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/serialization.jl#L132-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.serialize_lpcm" href="#Onda.serialize_lpcm"><code>Onda.serialize_lpcm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">serialize_lpcm(format::AbstractLPCMFormat, samples::AbstractMatrix)
serialize_lpcm(stream::AbstractLPCMStream, samples::AbstractMatrix)</code></pre><p>Return the <code>AbstractVector{UInt8}</code> of bytes that results from serializing <code>samples</code> to the given <code>format</code> (or serialize those bytes directly to <code>stream</code>) where <code>samples</code> is a channels-by-timesteps matrix of interleaved LPCM-encoded sample data.</p><p>Note that this operation may be performed in a zero-copy manner such that the returned <code>AbstractVector{UInt8}</code> directly aliases <code>samples</code>.</p><p>This function is the inverse of the corresponding <a href="#Onda.deserialize_lpcm"><code>deserialize_lpcm</code></a> method, i.e.:</p><pre><code class="nohighlight hljs">deserialize_lpcm(format, serialize_lpcm(format, samples)) == samples</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/serialization.jl#L160-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.deserialize_lpcm_callback" href="#Onda.deserialize_lpcm_callback"><code>Onda.deserialize_lpcm_callback</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deserialize_lpcm_callback(format::AbstractLPCMFormat, samples_offset, samples_count)</code></pre><p>Return <code>(callback, required_byte_offset, required_byte_count)</code> where <code>callback</code> accepts the byte block specified by <code>required_byte_offset</code> and <code>required_byte_count</code> and returns the samples specified by <code>samples_offset</code> and <code>samples_count</code>.</p><p>As a fallback, this function returns <code>(callback, missing, missing)</code>, where <code>callback</code> requires all available bytes. <code>AbstractLPCMFormat</code> subtypes that support partial/block-based deserialization (e.g. the basic <code>LPCMFormat</code>) can overload this function to only request exactly the byte range that is required for the sample range requested by the caller.</p><p>This allows callers to handle the byte block retrieval themselves while keeping Onda&#39;s LPCM Serialization API agnostic to the caller&#39;s storage layer of choice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/serialization.jl#L79-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.deserializing_lpcm_stream" href="#Onda.deserializing_lpcm_stream"><code>Onda.deserializing_lpcm_stream</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deserializing_lpcm_stream(format::AbstractLPCMFormat, io)</code></pre><p>Return a <code>stream::AbstractLPCMStream</code> that wraps <code>io</code> to enable direct LPCM deserialization from <code>io</code> via <a href="#Onda.deserialize_lpcm"><code>deserialize_lpcm</code></a>.</p><p>Note that <code>stream</code> must be finalized after usage via <a href="#Onda.finalize_lpcm_stream"><code>finalize_lpcm_stream</code></a>. Until <code>stream</code> is finalized, <code>io</code> should be considered to be part of the internal state of <code>stream</code> and should not be directly interacted with by other processes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/serialization.jl#L99-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.serializing_lpcm_stream" href="#Onda.serializing_lpcm_stream"><code>Onda.serializing_lpcm_stream</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">serializing_lpcm_stream(format::AbstractLPCMFormat, io)</code></pre><p>Return a <code>stream::AbstractLPCMStream</code> that wraps <code>io</code> to enable direct LPCM serialization to <code>io</code> via <a href="#Onda.serialize_lpcm"><code>serialize_lpcm</code></a>.</p><p>Note that <code>stream</code> must be finalized after usage via <a href="#Onda.finalize_lpcm_stream"><code>finalize_lpcm_stream</code></a>. Until <code>stream</code> is finalized, <code>io</code> should be considered to be part of the internal state of <code>stream</code> and should not be directly interacted with by other processes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/serialization.jl#L111-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.finalize_lpcm_stream" href="#Onda.finalize_lpcm_stream"><code>Onda.finalize_lpcm_stream</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">finalize_lpcm_stream(stream::AbstractLPCMStream)::Bool</code></pre><p>Finalize <code>stream</code>, returning <code>true</code> if the underlying I/O object used to construct <code>stream</code> is still open and usable. Otherwise, return <code>false</code> to indicate that underlying I/O object was closed as result of finalization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/serialization.jl#L123-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.register_lpcm_format!" href="#Onda.register_lpcm_format!"><code>Onda.register_lpcm_format!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Onda.register_lpcm_format!(create_constructor)</code></pre><p>Register an <code>AbstractLPCMFormat</code> constructor so that it can automatically be used when <a href="#Onda.format"><code>format</code></a> is called. Authors of new <code>AbstractLPCMFormat</code> subtypes should call this function for their subtype.</p><p><code>create_constructor</code> should be a unary function that accepts a single <code>file_format::AbstractString</code> argument, and return either a matching <code>AbstractLPCMFormat</code> constructor or <code>nothing</code>. Any returned <code>AbstractLPCMFormat</code> constructor <code>f</code> should be of the form <code>f(info; kwargs...)::AbstractLPCMFormat</code> where <code>info</code> is a <a href="#Onda.SamplesInfoV2"><code>SamplesInfoV2</code></a>-compliant value.</p><p>Note that if <code>Onda.register_lpcm_format!</code> is called in a downstream package, it must be called within the <code>__init__</code> function of the package&#39;s top-level module to ensure that the function is always invoked when the module is loaded (not just during precompilation). For details, see https://docs.julialang.org/en/v1/manual/modules/#Module-initialization-and-precompilation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/serialization.jl#L7-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.file_format_string" href="#Onda.file_format_string"><code>Onda.file_format_string</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">file_format_string(format::AbstractLPCMFormat)</code></pre><p>Return the <code>String</code> representation of <code>format</code> to be written to the <code>file_format</code> field of a <code>*.signals</code> file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/serialization.jl#L180-L184">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Onda.VALIDATE_SAMPLES_DEFAULT" href="#Onda.VALIDATE_SAMPLES_DEFAULT"><code>Onda.VALIDATE_SAMPLES_DEFAULT</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">VALIDATE_SAMPLES_DEFAULT[]</code></pre><p>Defaults to <code>true</code>.</p><p>When set to <code>true</code>, <code>Samples</code> objects will be validated upon construction for compliance with the Onda specification.</p><p>Users may interactively set this reference to <code>false</code> in order to disable this extra layer validation, which can be useful when working with malformed Onda datasets.</p><p>See also: <a href="@ref"><code>Onda.validate_samples</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/samples.jl#L5-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Onda.upgrade" href="#Onda.upgrade"><code>Onda.upgrade</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Onda.upgrade(from::SignalV1, ::SignalV2SchemaVersion)</code></pre><p>Return a <code>SignalV2</code> instance that represents <code>from</code> in the <code>SignalV2SchemaVersion</code> format.</p><p>The fields of the output will match <code>from</code>&#39;s fields, except:</p><ul><li>The <code>kind</code> field will be removed.</li><li>The <code>sensor_label=from.kind</code> field will be added.</li><li>The <code>sensor_type=from.kind</code> field will be added.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Onda.jl/blob/4153b509427cf607bbc6c82efc09bb0ac2f5bbf5/src/deprecations.jl#L80-L90">source</a></section></article><h2 id="Developer-Installation"><a class="docs-heading-anchor" href="#Developer-Installation">Developer Installation</a><a id="Developer-Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Developer-Installation" title="Permalink"></a></h2><p>To install Onda for development, run:</p><pre><code class="nohighlight hljs">julia -e &#39;using Pkg; Pkg.develop(&quot;Onda&quot;)&#39;</code></pre><p>This will install Onda to the default package development directory, <code>~/.julia/dev/Onda</code>.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="upgrading/">Upgrading From Older Versions Of Onda »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 13 September 2024 00:36">Friday 13 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
